#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"perl5/DateTime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME';
  ## no critic (Modules::ProhibitExcessMainComplexity)
  package DateTime;
  
  use 5.008004;
  
  use strict;
  use warnings;
  use warnings::register;
  use namespace::autoclean 0.19;
  
  our $VERSION = '1.54';
  
  use Carp;
  use DateTime::Duration;
  use DateTime::Helpers;
  use DateTime::Locale 1.06;
  use DateTime::TimeZone 2.44;
  use DateTime::Types;
  use POSIX qw( floor fmod );
  use Params::ValidationCompiler 0.26 qw( validation_for );
  use Scalar::Util qw( blessed );
  use Try::Tiny;
  
  ## no critic (Variables::ProhibitPackageVars)
  our $IsPurePerl;
  
  {
      my $loaded = 0;
  
      unless ( $ENV{PERL_DATETIME_PP} ) {
          try {
              require XSLoader;
              XSLoader::load(
                  __PACKAGE__,
                  exists $DateTime::{VERSION} && ${ $DateTime::{VERSION} }
                  ? ${ $DateTime::{VERSION} }
                  : 42
              );
  
              $loaded     = 1;
              $IsPurePerl = 0;
          }
          catch {
              die $_ if $_ && $_ !~ /object version|loadable object/;
          };
      }
  
      if ($loaded) {
          ## no critic (Variables::ProtectPrivateVars)
          require DateTime::PPExtra
              unless defined &DateTime::_normalize_tai_seconds;
      }
      else {
          require DateTime::PP;
      }
  }
  
  # for some reason, overloading doesn't work unless fallback is listed
  # early.
  #
  # 3rd parameter ( $_[2] ) means the parameters are 'reversed'.
  # see: "Calling conventions for binary operations" in overload docs.
  #
  use overload (
      fallback => 1,
      '<=>'    => '_compare_overload',
      'cmp'    => '_string_compare_overload',
      q{""}    => 'stringify',
      bool     => sub {1},
      '-'      => '_subtract_overload',
      '+'      => '_add_overload',
      'eq'     => '_string_equals_overload',
      'ne'     => '_string_not_equals_overload',
  );
  
  # Have to load this after overloading is defined, after BEGIN blocks
  # or else weird crashes ensue
  require DateTime::Infinite;
  
  sub MAX_NANOSECONDS () {1_000_000_000}                  # 1E9 = almost 32 bits
  sub INFINITY ()        { 100**100**100**100 }
  sub NEG_INFINITY ()    { -1 * ( 100**100**100**100 ) }
  sub NAN ()             { INFINITY - INFINITY }
  
  sub SECONDS_PER_DAY () {86400}
  
  sub duration_class () {'DateTime::Duration'}
  
  my (
      @MonthLengths,
      @LeapYearMonthLengths,
      @QuarterLengths,
      @LeapYearQuarterLengths,
  );
  
  BEGIN {
      @MonthLengths = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
      @LeapYearMonthLengths = @MonthLengths;
      $LeapYearMonthLengths[1]++;
  
      @QuarterLengths = ( 90, 91, 92, 92 );
  
      @LeapYearQuarterLengths = @QuarterLengths;
      $LeapYearQuarterLengths[0]++;
  }
  
  {
  
      # I'd rather use Class::Data::Inheritable for this, but there's no
      # way to add the module-loading behavior to an accessor it
      # creates, despite what its docs say!
      my $DefaultLocale;
  
      sub DefaultLocale {
          shift;
  
          if (@_) {
              my $lang = shift;
  
              $DefaultLocale = DateTime::Locale->load($lang);
          }
  
          return $DefaultLocale;
      }
  }
  __PACKAGE__->DefaultLocale('en-US');
  
  {
      my $validator = validation_for(
          name             => '_check_new_params',
          name_is_optional => 1,
          params           => {
              year  => { type => t('Year') },
              month => {
                  type    => t('Month'),
                  default => 1,
              },
              day => {
                  type    => t('DayOfMonth'),
                  default => 1,
              },
              hour => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub new {
          my $class = shift;
          my %p     = $validator->(@_);
  
          Carp::croak(
              "Invalid day of month (day = $p{day} - month = $p{month} - year = $p{year})\n"
              )
              if $p{day} > 28
              && $p{day} > $class->_month_length( $p{year}, $p{month} );
  
          return $class->_new(%p);
      }
  }
  
  sub _new {
      my $class = shift;
      my %p     = @_;
  
      Carp::croak('Constructor called with reference, we expected a package')
          if ref $class;
  
      # If this method is called from somewhere other than new(), then some of
      # these defaults may not get applied.
      $p{month}      = 1                          unless exists $p{month};
      $p{day}        = 1                          unless exists $p{day};
      $p{hour}       = 0                          unless exists $p{hour};
      $p{minute}     = 0                          unless exists $p{minute};
      $p{second}     = 0                          unless exists $p{second};
      $p{nanosecond} = 0                          unless exists $p{nanosecond};
      $p{time_zone}  = $class->_default_time_zone unless exists $p{time_zone};
  
      my $self = bless {}, $class;
  
      $self->_set_locale( $p{locale} );
  
      $self->{tz} = (
          ref $p{time_zone}
          ? $p{time_zone}
          : DateTime::TimeZone->new( name => $p{time_zone} )
      );
  
      $self->{local_rd_days} = $class->_ymd2rd( @p{qw( year month day )} );
  
      $self->{local_rd_secs}
          = $class->_time_as_seconds( @p{qw( hour minute second )} );
  
      $self->{offset_modifier} = 0;
  
      $self->{rd_nanosecs} = $p{nanosecond};
      $self->{formatter}   = $p{formatter};
  
      $self->_normalize_nanoseconds(
          $self->{local_rd_secs},
          $self->{rd_nanosecs}
      );
  
      # Set this explicitly since it can't be calculated accurately
      # without knowing our time zone offset, and it's possible that the
      # offset can't be calculated without having at least a rough guess
      # of the datetime's year. This year need not be correct, as long
      # as its equal or greater to the correct number, so we fudge by
      # adding one to the local year given to the constructor.
      $self->{utc_year} = $p{year} + 1;
  
      $self->_maybe_future_dst_warning( $p{year}, $p{time_zone} );
  
      $self->_calc_utc_rd;
  
      $self->_handle_offset_modifier( $p{second} );
  
      $self->_calc_local_rd;
  
      if ( $p{second} > 59 ) {
          if (
              $self->{tz}->is_floating
              ||
  
              # If true, this means that the actual calculated leap
              # second does not occur in the second given to new()
              ( $self->{utc_rd_secs} - 86399 < $p{second} - 59 )
          ) {
              Carp::croak("Invalid second value ($p{second})\n");
          }
      }
  
      return $self;
  }
  
  # Warning: do not use this environment variable unless you have no choice in
  # the matter.
  sub _default_time_zone {
      return $ENV{PERL_DATETIME_DEFAULT_TZ} || 'floating';
  }
  
  sub _set_locale {
      my $self   = shift;
      my $locale = shift;
  
      if ( defined $locale && ref $locale ) {
          $self->{locale} = $locale;
      }
      else {
          $self->{locale}
              = $locale
              ? DateTime::Locale->load($locale)
              : $self->DefaultLocale;
      }
  
      return;
  }
  
  # This method exists for the benefit of internal methods which create
  # a new object based on the current object, like set() and truncate().
  sub _new_from_self {
      my $self = shift;
      my %p    = @_;
  
      my %old = map { $_ => $self->$_() } qw(
          year month day
          hour minute second
          nanosecond
          locale time_zone
      );
      $old{formatter} = $self->formatter
          if defined $self->formatter;
  
      my $method = delete $p{_skip_validation} ? '_new' : 'new';
  
      return ( ref $self )->$method( %old, %p );
  }
  
  sub _handle_offset_modifier {
      my $self = shift;
  
      $self->{offset_modifier} = 0;
  
      return if $self->{tz}->is_floating;
  
      my $second       = shift;
      my $utc_is_valid = shift;
  
      my $utc_rd_days = $self->{utc_rd_days};
  
      my $offset
          = $utc_is_valid ? $self->offset : $self->_offset_for_local_datetime;
  
      if (   $offset >= 0
          && $self->{local_rd_secs} >= $offset ) {
          if ( $second < 60 && $offset > 0 ) {
              $self->{offset_modifier}
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              $self->{local_rd_secs} += $self->{offset_modifier};
          }
          elsif (
              $second == 60
              && (
                  ( $self->{local_rd_secs} == $offset && $offset > 0 )
                  || (   $offset == 0
                      && $self->{local_rd_secs} > 86399 )
              )
          ) {
              my $mod
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              unless ( $mod == 0 ) {
                  $self->{utc_rd_secs} -= $mod;
  
                  $self->_normalize_seconds;
              }
          }
      }
      elsif ($offset < 0
          && $self->{local_rd_secs} >= SECONDS_PER_DAY + $offset ) {
          if ( $second < 60 ) {
              $self->{offset_modifier}
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              $self->{local_rd_secs} += $self->{offset_modifier};
          }
          elsif ($second == 60
              && $self->{local_rd_secs} == SECONDS_PER_DAY + $offset ) {
              my $mod
                  = $self->_day_length( $utc_rd_days - 1 ) - SECONDS_PER_DAY;
  
              unless ( $mod == 0 ) {
                  $self->{utc_rd_secs} -= $mod;
  
                  $self->_normalize_seconds;
              }
          }
      }
  }
  
  sub _calc_utc_rd {
      my $self = shift;
  
      delete $self->{utc_c};
  
      if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
          $self->{utc_rd_days} = $self->{local_rd_days};
          $self->{utc_rd_secs} = $self->{local_rd_secs};
      }
      else {
          my $offset = $self->_offset_for_local_datetime;
  
          $offset += $self->{offset_modifier};
  
          $self->{utc_rd_days} = $self->{local_rd_days};
          $self->{utc_rd_secs} = $self->{local_rd_secs} - $offset;
      }
  
      # We account for leap seconds in the new() method and nowhere else
      # except date math.
      $self->_normalize_tai_seconds(
          $self->{utc_rd_days},
          $self->{utc_rd_secs}
      );
  }
  
  sub _normalize_seconds {
      my $self = shift;
  
      return if $self->{utc_rd_secs} >= 0 && $self->{utc_rd_secs} <= 86399;
  
      if ( $self->{tz}->is_floating ) {
          $self->_normalize_tai_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
      else {
          $self->_normalize_leap_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
  }
  
  sub _calc_local_rd {
      my $self = shift;
  
      delete $self->{local_c};
  
      # We must short circuit for UTC times or else we could end up with
      # loops between DateTime.pm and DateTime::TimeZone
      if ( $self->{tz}->is_utc || $self->{tz}->is_floating ) {
          $self->{local_rd_days} = $self->{utc_rd_days};
          $self->{local_rd_secs} = $self->{utc_rd_secs};
      }
      else {
          my $offset = $self->offset;
  
          $self->{local_rd_days} = $self->{utc_rd_days};
          $self->{local_rd_secs} = $self->{utc_rd_secs} + $offset;
  
          # intentionally ignore leap seconds here
          $self->_normalize_tai_seconds(
              $self->{local_rd_days},
              $self->{local_rd_secs}
          );
  
          $self->{local_rd_secs} += $self->{offset_modifier};
      }
  
      $self->_calc_local_components;
  }
  
  sub _calc_local_components {
      my $self = shift;
  
      @{ $self->{local_c} }{
          qw( year month day day_of_week
              day_of_year quarter day_of_quarter)
          }
          = $self->_rd2ymd( $self->{local_rd_days}, 1 );
  
      @{ $self->{local_c} }{qw( hour minute second )}
          = $self->_seconds_as_components(
          $self->{local_rd_secs},
          $self->{utc_rd_secs}, $self->{offset_modifier}
          );
  }
  
  {
      my $validator = validation_for(
          name             => '_check_from_epoch_params',
          name_is_optional => 1,
          params           => {
              epoch     => { type => t('Num') },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1
              },
          },
      );
  
      sub from_epoch {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my %args;
  
          # This does two things. First, if given a negative non-integer epoch,
          # it will round the epoch _down_ to the next second and then adjust
          # the nanoseconds to be positive. In other words, -0.5 corresponds to
          # a second of -1 and a nanosecond value of 500,000. Before this code
          # was implemented our handling of negative non-integer epochs was
          # quite broken, and would end up rounding some values up, so that -0.5
          # become 0.5 (which is obviously wrong!).
          #
          # Second, it rounds any decimal values to the nearest microsecond
          # (1E6). Here's what Christian Hansen, who wrote this patch, says:
          #
          #     Perl is typically compiled with NV as a double. A double with a
          #     significand precision of 53 bits can only represent a nanosecond
          #     epoch without loss of precision if the duration from zero epoch
          #     is less than ≈ ±104 days. With microseconds the duration is
          #     ±104,000 days, which is ≈ ±285 years.
          if ( int $p{epoch} != $p{epoch} ) {
              my ( $floor, $nano, $second );
  
              $floor  = $nano = fmod( $p{epoch}, 1.0 );
              $second = floor( $p{epoch} - $floor );
              if ( $nano < 0 ) {
                  $nano += 1;
              }
              $p{epoch}         = $second + floor( $floor - $nano );
              $args{nanosecond} = floor( $nano * 1E6 + 0.5 ) * 1E3;
          }
  
          # Note, for very large negative values this may give a
          # blatantly wrong answer.
          @args{qw( second minute hour day month year )}
              = ( gmtime( $p{epoch} ) )[ 0 .. 5 ];
          $args{year} += 1900;
          $args{month}++;
  
          my $self = $class->_new( %p, %args, time_zone => 'UTC' );
  
          $self->_maybe_future_dst_warning( $self->year, $p{time_zone} );
  
          $self->set_time_zone( $p{time_zone} ) if exists $p{time_zone};
  
          return $self;
      }
  }
  
  sub now {
      my $class = shift;
      return $class->from_epoch( epoch => $class->_core_time, @_ );
  }
  
  sub _maybe_future_dst_warning {
      shift;
      my $year = shift;
      my $tz   = shift;
  
      return unless $year >= 5000 && $tz;
  
      my $tz_name = ref $tz ? $tz->name : $tz;
      return if $tz_name eq 'floating' || $tz_name eq 'UTC';
  
      warnings::warnif(
          "You are creating a DateTime object with a far future year ($year) and a time zone ($tz_name)."
              . ' If the time zone you specified has future DST changes this will be very slow.'
      );
  }
  
  # use scalar time in case someone's loaded Time::Piece
  sub _core_time {
      return scalar time;
  }
  
  sub today { shift->now(@_)->truncate( to => 'day' ) }
  
  {
      my $validator = validation_for(
          name             => '_check_from_object_params',
          name_is_optional => 1,
          params           => {
              object => { type => t('ConvertibleObject') },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
          },
      );
  
      sub from_object {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my $object = delete $p{object};
  
          if ( $object->isa('DateTime::Infinite') ) {
              return $object->clone;
          }
  
          my ( $rd_days, $rd_secs, $rd_nanosecs ) = $object->utc_rd_values;
  
          # A kludge because until all calendars are updated to return all
          # three values, $rd_nanosecs could be undef
          $rd_nanosecs ||= 0;
  
          # This is a big hack to let _seconds_as_components operate naively
          # on the given value. If the object _is_ on a leap second, we'll
          # add that to the generated seconds value later.
          my $leap_seconds = 0;
          if (   $object->can('time_zone')
              && !$object->time_zone->is_floating
              && $rd_secs > 86399
              && $rd_secs <= $class->_day_length($rd_days) ) {
              $leap_seconds = $rd_secs - 86399;
              $rd_secs -= $leap_seconds;
          }
  
          my %args;
          @args{qw( year month day )} = $class->_rd2ymd($rd_days);
          @args{qw( hour minute second )}
              = $class->_seconds_as_components($rd_secs);
          $args{nanosecond} = $rd_nanosecs;
  
          $args{second} += $leap_seconds;
  
          my $new = $class->new( %p, %args, time_zone => 'UTC' );
  
          if ( $object->can('time_zone') ) {
              $new->set_time_zone( $object->time_zone );
          }
          else {
              $new->set_time_zone( $class->_default_time_zone );
          }
  
          return $new;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_last_day_of_month_params',
          name_is_optional => 1,
          params           => {
              year  => { type => t('Year') },
              month => { type => t('Month') },
              day   => {
                  type    => t('DayOfMonth'),
                  default => 1,
              },
              hour => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub last_day_of_month {
          my $class = shift;
          my %p     = $validator->(@_);
  
          my $day = $class->_month_length( $p{year}, $p{month} );
  
          return $class->_new( %p, day => $day );
      }
  }
  
  sub _month_length {
      return (
            $_[0]->_is_leap_year( $_[1] )
          ? $LeapYearMonthLengths[ $_[2] - 1 ]
          : $MonthLengths[ $_[2] - 1 ]
      );
  }
  
  {
      my $validator = validation_for(
          name             => '_check_from_day_of_year_params',
          name_is_optional => 1,
          params           => {
              year        => { type => t('Year') },
              day_of_year => { type => t('DayOfYear') },
              hour        => {
                  type    => t('Hour'),
                  default => 0,
              },
              minute => {
                  type    => t('Minute'),
                  default => 0,
              },
              second => {
                  type    => t('Second'),
                  default => 0,
              },
              nanosecond => {
                  type    => t('Nanosecond'),
                  default => 0,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
              formatter => {
                  type     => t('Formatter'),
                  optional => 1,
              },
              time_zone => {
                  type     => t('TimeZone'),
                  optional => 1,
              },
          },
      );
  
      sub from_day_of_year {
          my $class = shift;
          my %p     = $validator->(@_);
  
          Carp::croak("$p{year} is not a leap year.\n")
              if $p{day_of_year} == 366 && !$class->_is_leap_year( $p{year} );
  
          my $month = 1;
          my $day   = delete $p{day_of_year};
  
          if ( $day > 31 ) {
              my $length = $class->_month_length( $p{year}, $month );
  
              while ( $day > $length ) {
                  $day -= $length;
                  $month++;
                  $length = $class->_month_length( $p{year}, $month );
              }
          }
  
          return $class->_new(
              %p,
              month => $month,
              day   => $day,
          );
      }
  }
  
  sub formatter { $_[0]->{formatter} }
  
  sub clone { bless { %{ $_[0] } }, ref $_[0] }
  
  sub year {
      Carp::carp('year() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{year};
  }
  
  sub ce_year {
      $_[0]->{local_c}{year} <= 0
          ? $_[0]->{local_c}{year} - 1
          : $_[0]->{local_c}{year};
  }
  
  sub era_name { $_[0]->{locale}->era_wide->[ $_[0]->_era_index ] }
  
  sub era_abbr { $_[0]->{locale}->era_abbreviated->[ $_[0]->_era_index ] }
  
  # deprecated
  *era = \&era_abbr;
  
  sub _era_index { $_[0]->{local_c}{year} <= 0 ? 0 : 1 }
  
  sub christian_era { $_[0]->ce_year > 0 ? 'AD' : 'BC' }
  sub secular_era   { $_[0]->ce_year > 0 ? 'CE' : 'BCE' }
  
  sub year_with_era           { ( abs $_[0]->ce_year ) . $_[0]->era_abbr }
  sub year_with_christian_era { ( abs $_[0]->ce_year ) . $_[0]->christian_era }
  sub year_with_secular_era   { ( abs $_[0]->ce_year ) . $_[0]->secular_era }
  
  sub month {
      Carp::carp('month() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{month};
  }
  *mon = \&month;
  
  sub month_0 { $_[0]->{local_c}{month} - 1 }
  *mon_0 = \&month_0;
  
  sub month_name { $_[0]->{locale}->month_format_wide->[ $_[0]->month_0 ] }
  
  sub month_abbr {
      $_[0]->{locale}->month_format_abbreviated->[ $_[0]->month_0 ];
  }
  
  sub day_of_month {
      Carp::carp('day_of_month() is a read-only accessor') if @_ > 1;
      $_[0]->{local_c}{day};
  }
  *day  = \&day_of_month;
  *mday = \&day_of_month;
  
  sub weekday_of_month { use integer; ( ( $_[0]->day - 1 ) / 7 ) + 1 }
  
  sub quarter { $_[0]->{local_c}{quarter} }
  
  sub quarter_name {
      $_[0]->{locale}->quarter_format_wide->[ $_[0]->quarter_0 ];
  }
  
  sub quarter_abbr {
      $_[0]->{locale}->quarter_format_abbreviated->[ $_[0]->quarter_0 ];
  }
  
  sub quarter_0 { $_[0]->{local_c}{quarter} - 1 }
  
  sub day_of_month_0 { $_[0]->{local_c}{day} - 1 }
  *day_0  = \&day_of_month_0;
  *mday_0 = \&day_of_month_0;
  
  sub day_of_week { $_[0]->{local_c}{day_of_week} }
  *wday = \&day_of_week;
  *dow  = \&day_of_week;
  
  sub day_of_week_0 { $_[0]->{local_c}{day_of_week} - 1 }
  *wday_0 = \&day_of_week_0;
  *dow_0  = \&day_of_week_0;
  
  sub local_day_of_week {
      my $self = shift;
      return 1
          + ( $self->day_of_week - $self->{locale}->first_day_of_week ) % 7;
  }
  
  sub day_name { $_[0]->{locale}->day_format_wide->[ $_[0]->day_of_week_0 ] }
  
  sub day_abbr {
      $_[0]->{locale}->day_format_abbreviated->[ $_[0]->day_of_week_0 ];
  }
  
  sub day_of_quarter { $_[0]->{local_c}{day_of_quarter} }
  *doq = \&day_of_quarter;
  
  sub day_of_quarter_0 { $_[0]->day_of_quarter - 1 }
  *doq_0 = \&day_of_quarter_0;
  
  sub day_of_year { $_[0]->{local_c}{day_of_year} }
  *doy = \&day_of_year;
  
  sub day_of_year_0 { $_[0]->{local_c}{day_of_year} - 1 }
  *doy_0 = \&day_of_year_0;
  
  sub am_or_pm {
      $_[0]->{locale}->am_pm_abbreviated->[ $_[0]->hour < 12 ? 0 : 1 ];
  }
  
  sub ymd {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.4d%s%0.2d%s%0.2d',
          $self->year,             $sep,
          $self->{local_c}{month}, $sep,
          $self->{local_c}{day}
      );
  }
  *date = sub { shift->ymd(@_) };
  
  sub mdy {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.4d',
          $self->{local_c}{month}, $sep,
          $self->{local_c}{day},   $sep,
          $self->year
      );
  }
  
  sub dmy {
      my ( $self, $sep ) = @_;
      $sep = '-' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.4d',
          $self->{local_c}{day},   $sep,
          $self->{local_c}{month}, $sep,
          $self->year
      );
  }
  
  sub hour {
      Carp::carp('hour() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{hour};
  }
  sub hour_1 { $_[0]->{local_c}{hour} == 0 ? 24 : $_[0]->{local_c}{hour} }
  
  sub hour_12   { my $h = $_[0]->hour % 12; return $h ? $h : 12 }
  sub hour_12_0 { $_[0]->hour % 12 }
  
  sub minute {
      Carp::carp('minute() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{minute};
  }
  *min = \&minute;
  
  sub second {
      Carp::carp('second() is a read-only accessor') if @_ > 1;
      return $_[0]->{local_c}{second};
  }
  *sec = \&second;
  
  sub fractional_second { $_[0]->second + $_[0]->nanosecond / MAX_NANOSECONDS }
  
  sub nanosecond {
      Carp::carp('nanosecond() is a read-only accessor') if @_ > 1;
      return $_[0]->{rd_nanosecs};
  }
  
  sub millisecond { floor( $_[0]->{rd_nanosecs} / 1000000 ) }
  
  sub microsecond { floor( $_[0]->{rd_nanosecs} / 1000 ) }
  
  sub leap_seconds {
      my $self = shift;
  
      return 0 if $self->{tz}->is_floating;
  
      return $self->_accumulated_leap_seconds( $self->{utc_rd_days} );
  }
  
  sub stringify {
      my $self = shift;
  
      return $self->iso8601 unless $self->{formatter};
      return $self->{formatter}->format_datetime($self);
  }
  
  sub hms {
      my ( $self, $sep ) = @_;
      $sep = ':' unless defined $sep;
  
      return sprintf(
          '%0.2d%s%0.2d%s%0.2d',
          $self->{local_c}{hour},   $sep,
          $self->{local_c}{minute}, $sep,
          $self->{local_c}{second}
      );
  }
  
  # don't want to override CORE::time()
  *DateTime::time = sub { shift->hms(@_) };
  
  sub iso8601 { $_[0]->datetime('T') }
  
  sub rfc3339 {
      my $self = shift;
  
      return $self->datetime('T')
          if $self->{tz}->is_floating;
  
      my $secs = $self->offset;
      my $offset
          = $secs
          ? DateTime::TimeZone->offset_as_string( $secs, q{:} )
          : 'Z';
  
      return $self->datetime('T') . $offset;
  }
  
  sub datetime {
      my ( $self, $sep ) = @_;
      $sep = 'T' unless defined $sep;
      return join $sep, $self->ymd('-'), $self->hms(':');
  }
  
  sub is_leap_year { $_[0]->_is_leap_year( $_[0]->year ) }
  
  sub month_length {
      $_[0]->_month_length( $_[0]->year, $_[0]->month );
  }
  
  sub quarter_length {
      return (
            $_[0]->_is_leap_year( $_[0]->year )
          ? $LeapYearQuarterLengths[ $_[0]->quarter - 1 ]
          : $QuarterLengths[ $_[0]->quarter - 1 ]
      );
  }
  
  sub year_length {
      $_[0]->_is_leap_year( $_[0]->year ) ? 366 : 365;
  }
  
  sub is_last_day_of_month {
      $_[0]->day == $_[0]->_month_length( $_[0]->year, $_[0]->month );
  }
  
  sub is_last_day_of_quarter {
      $_[0]->day_of_quarter == $_[0]->quarter_length;
  }
  
  sub is_last_day_of_year {
      $_[0]->day_of_year == $_[0]->year_length;
  }
  
  sub week {
      my $self = shift;
  
      $self->{utc_c}{week_year} ||= $self->_week_values;
  
      return @{ $self->{utc_c}{week_year} }[ 0, 1 ];
  }
  
  # This algorithm comes from
  # https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_of_a_given_date
  sub _week_values {
      my $self = shift;
  
      my $week
          = int( ( ( $self->day_of_year - $self->day_of_week ) + 10 ) / 7 );
  
      my $year = $self->year;
      if ( $week == 0 ) {
          $year--;
          return [ $year, $self->_weeks_in_year($year) ];
      }
      elsif ( $week == 53 && $self->_weeks_in_year($year) == 52 ) {
          return [ $year + 1, 1 ];
      }
  
      return [ $year, $week ];
  }
  
  sub _weeks_in_year {
      my $self = shift;
      my $year = shift;
  
      my $dow = $self->_ymd2rd( $year, 1, 1 ) % 7;
  
      # Years starting with a Thursday and leap years starting with a Wednesday
      # have 53 weeks.
      return ( $dow == 4 || ( $dow == 3 && $self->_is_leap_year($year) ) )
          ? 53
          : 52;
  }
  
  sub week_year   { ( $_[0]->week )[0] }
  sub week_number { ( $_[0]->week )[1] }
  
  # ISO says that the first week of a year is the first week containing
  # a Thursday. Extending that says that the first week of the month is
  # the first week containing a Thursday. ICU agrees.
  sub week_of_month {
      my $self = shift;
      my $thu  = $self->day + 4 - $self->day_of_week;
      return int( ( $thu + 6 ) / 7 );
  }
  
  sub time_zone {
      Carp::carp('time_zone() is a read-only accessor') if @_ > 1;
      return $_[0]->{tz};
  }
  
  sub offset { $_[0]->{tz}->offset_for_datetime( $_[0] ) }
  
  sub _offset_for_local_datetime {
      $_[0]->{tz}->offset_for_local_datetime( $_[0] );
  }
  
  sub is_dst { $_[0]->{tz}->is_dst_for_datetime( $_[0] ) }
  
  sub time_zone_long_name  { $_[0]->{tz}->name }
  sub time_zone_short_name { $_[0]->{tz}->short_name_for_datetime( $_[0] ) }
  
  sub locale {
      Carp::carp('locale() is a read-only accessor') if @_ > 1;
      return $_[0]->{locale};
  }
  
  sub utc_rd_values {
      @{ $_[0] }{ 'utc_rd_days', 'utc_rd_secs', 'rd_nanosecs' };
  }
  
  sub local_rd_values {
      @{ $_[0] }{ 'local_rd_days', 'local_rd_secs', 'rd_nanosecs' };
  }
  
  # NOTE: no nanoseconds, no leap seconds
  sub utc_rd_as_seconds {
      ( $_[0]->{utc_rd_days} * SECONDS_PER_DAY ) + $_[0]->{utc_rd_secs};
  }
  
  # NOTE: no nanoseconds, no leap seconds
  sub local_rd_as_seconds {
      ( $_[0]->{local_rd_days} * SECONDS_PER_DAY ) + $_[0]->{local_rd_secs};
  }
  
  # RD 1 is MJD 678,576 - a simple offset
  sub mjd {
      my $self = shift;
  
      my $mjd = $self->{utc_rd_days} - 678_576;
  
      my $day_length = $self->_day_length( $self->{utc_rd_days} );
  
      return (  $mjd
              + ( $self->{utc_rd_secs} / $day_length )
              + ( $self->{rd_nanosecs} / $day_length / MAX_NANOSECONDS ) );
  }
  
  sub jd { $_[0]->mjd + 2_400_000.5 }
  
  {
      my %strftime_patterns = (
          'a' => sub { $_[0]->day_abbr },
          'A' => sub { $_[0]->day_name },
          'b' => sub { $_[0]->month_abbr },
          'B' => sub { $_[0]->month_name },
          'c' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->datetime_format_default );
          },
          'C' => sub { int( $_[0]->year / 100 ) },
          'd' => sub { sprintf( '%02d', $_[0]->day_of_month ) },
          'D' => sub { $_[0]->strftime('%m/%d/%y') },
          'e' => sub { sprintf( '%2d', $_[0]->day_of_month ) },
          'F' => sub { $_[0]->strftime('%Y-%m-%d') },
          'g' => sub { substr( $_[0]->week_year, -2 ) },
          'G' => sub { $_[0]->week_year },
          'H' => sub { sprintf( '%02d', $_[0]->hour ) },
          'I' => sub { sprintf( '%02d', $_[0]->hour_12 ) },
          'j' => sub { sprintf( '%03d', $_[0]->day_of_year ) },
          'k' => sub { sprintf( '%2d',  $_[0]->hour ) },
          'l' => sub { sprintf( '%2d',  $_[0]->hour_12 ) },
          'm' => sub { sprintf( '%02d', $_[0]->month ) },
          'M' => sub { sprintf( '%02d', $_[0]->minute ) },
          'n' => sub {"\n"},                   # should this be OS-sensitive?
          'N' => \&_format_nanosecs,
          'p' => sub { $_[0]->am_or_pm },
          'P' => sub { lc $_[0]->am_or_pm },
          'r' => sub { $_[0]->strftime('%I:%M:%S %p') },
          'R' => sub { $_[0]->strftime('%H:%M') },
          's' => sub { $_[0]->epoch },
          'S' => sub { sprintf( '%02d', $_[0]->second ) },
          't' => sub {"\t"},
          'T' => sub { $_[0]->strftime('%H:%M:%S') },
          'u' => sub { $_[0]->day_of_week },
          'U' => sub {
              my $sun = $_[0]->day_of_year - ( $_[0]->day_of_week + 7 ) % 7;
              return sprintf( '%02d', int( ( $sun + 6 ) / 7 ) );
          },
          'V' => sub { sprintf( '%02d', $_[0]->week_number ) },
          'w' => sub {
              my $dow = $_[0]->day_of_week;
              return $dow % 7;
          },
          'W' => sub {
              my $mon = $_[0]->day_of_year - ( $_[0]->day_of_week + 6 ) % 7;
              return sprintf( '%02d', int( ( $mon + 6 ) / 7 ) );
          },
          'x' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->date_format_default );
          },
          'X' => sub {
              $_[0]->format_cldr( $_[0]->{locale}->time_format_default );
          },
          'y' => sub { sprintf( '%02d', substr( $_[0]->year, -2 ) ) },
          'Y' => sub { return $_[0]->year },
          'z' => sub { DateTime::TimeZone->offset_as_string( $_[0]->offset ) },
          'Z' => sub { $_[0]->{tz}->short_name_for_datetime( $_[0] ) },
          '%' => sub {'%'},
      );
  
      $strftime_patterns{h} = $strftime_patterns{b};
  
      sub strftime {
          my $self = shift;
  
          # make a copy or caller's scalars get munged
          my @patterns = @_;
  
          my @r;
          foreach my $p (@patterns) {
              $p =~ s/
                      (?:
                        %\{(\w+)\}       # method name like %{day_name}
                        |
                        %([%a-zA-Z])     # single character specifier like %d
                        |
                        %(\d+)N          # special case for %N
                      )
                     /
                      ( $1
                        ? ( $self->can($1) ? $self->$1() : "\%{$1}" )
                        : $2
                        ? ( $strftime_patterns{$2} ? $strftime_patterns{$2}->($self) : "\%$2" )
                        : $3
                        ? $strftime_patterns{N}->($self, $3)
                        : ''  # this won't happen
                      )
                     /sgex;
  
              return $p unless wantarray;
  
              push @r, $p;
          }
  
          return @r;
      }
  }
  
  {
  
      # It's an array because the order in which the regexes are checked
      # is important. These patterns are similar to the ones Java uses,
      # but not quite the same. See
      # http://www.unicode.org/reports/tr35/tr35-9.html#Date_Format_Patterns.
      my @patterns = (
          qr/GGGGG/ =>
              sub { $_[0]->{locale}->era_narrow->[ $_[0]->_era_index ] },
          qr/GGGG/   => 'era_name',
          qr/G{1,3}/ => 'era_abbr',
  
          qr/(y{3,5})/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->year ) },
  
          # yy is a weird special case, where it must be exactly 2 digits
          qr/yy/ => sub {
              my $year = $_[0]->year;
              my $y2   = length $year > 2 ? substr( $year, -2, 2 ) : $year;
              $y2 *= -1 if $year < 0;
              $_[0]->_zero_padded_number( 'yy', $y2 );
          },
          qr/y/    => sub { $_[0]->year },
          qr/(u+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->year ) },
          qr/(Y+)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->week_year ) },
  
          qr/QQQQ/  => 'quarter_name',
          qr/QQQ/   => 'quarter_abbr',
          qr/(QQ?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter ) },
  
          qr/qqqq/ => sub {
              $_[0]->{locale}->quarter_stand_alone_wide->[ $_[0]->quarter_0 ];
          },
          qr/qqq/ => sub {
              $_[0]->{locale}
                  ->quarter_stand_alone_abbreviated->[ $_[0]->quarter_0 ];
          },
          qr/(qq?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->quarter ) },
  
          qr/MMMMM/ =>
              sub { $_[0]->{locale}->month_format_narrow->[ $_[0]->month_0 ] },
          qr/MMMM/  => 'month_name',
          qr/MMM/   => 'month_abbr',
          qr/(MM?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month ) },
  
          qr/LLLLL/ => sub {
              $_[0]->{locale}->month_stand_alone_narrow->[ $_[0]->month_0 ];
          },
          qr/LLLL/ => sub {
              $_[0]->{locale}->month_stand_alone_wide->[ $_[0]->month_0 ];
          },
          qr/LLL/ => sub {
              $_[0]->{locale}
                  ->month_stand_alone_abbreviated->[ $_[0]->month_0 ];
          },
          qr/(LL?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->month ) },
  
          qr/(ww?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->week_number ) },
          qr/W/ => 'week_of_month',
  
          qr/(dd?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_month ) },
          qr/(D{1,3})/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_year ) },
  
          qr/F/    => 'weekday_of_month',
          qr/(g+)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->mjd ) },
  
          qr/EEEEE/ => sub {
              $_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0 ];
          },
          qr/EEEE/   => 'day_name',
          qr/E{1,3}/ => 'day_abbr',
  
          qr/eeeee/ => sub {
              $_[0]->{locale}->day_format_narrow->[ $_[0]->day_of_week_0 ];
          },
          qr/eeee/  => 'day_name',
          qr/eee/   => 'day_abbr',
          qr/(ee?)/ => sub {
              $_[0]->_zero_padded_number( $1, $_[0]->local_day_of_week );
          },
  
          qr/ccccc/ => sub {
              $_[0]->{locale}->day_stand_alone_narrow->[ $_[0]->day_of_week_0 ];
          },
          qr/cccc/ => sub {
              $_[0]->{locale}->day_stand_alone_wide->[ $_[0]->day_of_week_0 ];
          },
          qr/ccc/ => sub {
              $_[0]->{locale}
                  ->day_stand_alone_abbreviated->[ $_[0]->day_of_week_0 ];
          },
          qr/(cc?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->day_of_week ) },
  
          qr/a/ => 'am_or_pm',
  
          qr/(hh?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12 ) },
          qr/(HH?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->hour ) },
          qr/(KK?)/ =>
              sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_12_0 ) },
          qr/(kk?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->hour_1 ) },
          qr/(jj?)/ => sub {
              my $h
                  = $_[0]->{locale}->prefers_24_hour_time
                  ? $_[0]->hour
                  : $_[0]->hour_12;
              $_[0]->_zero_padded_number( $1, $h );
          },
  
          qr/(mm?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->minute ) },
  
          qr/(ss?)/ => sub { $_[0]->_zero_padded_number( $1, $_[0]->second ) },
  
          # The LDML spec is not 100% clear on how to truncate this field, but
          # this way seems as good as anything.
          qr/(S+)/ => sub { $_[0]->_format_nanosecs( length($1) ) },
          qr/A+/   =>
              sub { ( $_[0]->{local_rd_secs} * 1000 ) + $_[0]->millisecond },
  
          qr/zzzz/   => sub { $_[0]->time_zone_long_name },
          qr/z{1,3}/ => sub { $_[0]->time_zone_short_name },
          qr/ZZZZZ/  => sub {
              DateTime::TimeZone->offset_as_string( $_[0]->offset, q{:} );
          },
          qr/ZZZZ/ => sub {
              $_[0]->time_zone_short_name
                  . DateTime::TimeZone->offset_as_string( $_[0]->offset );
          },
          qr/Z{1,3}/ =>
              sub { DateTime::TimeZone->offset_as_string( $_[0]->offset ) },
          qr/vvvv/   => sub { $_[0]->time_zone_long_name },
          qr/v{1,3}/ => sub { $_[0]->time_zone_short_name },
          qr/VVVV/   => sub { $_[0]->time_zone_long_name },
          qr/V{1,3}/ => sub { $_[0]->time_zone_short_name },
      );
  
      sub _zero_padded_number {
          my $self = shift;
          my $size = length shift;
          my $val  = shift;
  
          return sprintf( "%0${size}d", $val );
      }
  
      sub format_cldr {
          my $self = shift;
  
          # make a copy or caller's scalars get munged
          my @p = @_;
  
          my @r;
          foreach my $p (@p) {
              $p =~ s/\G
                      (?:
                        '((?:[^']|'')*)' # quote escaped bit of text
                                         # it needs to end with one
                                         # quote not followed by
                                         # another
                        |
                        (([a-zA-Z])\3*)     # could be a pattern
                        |
                        (.)                 # anything else
                      )
                     /
                      defined $1
                      ? $1
                      : defined $2
                      ? $self->_cldr_pattern($2)
                      : defined $4
                      ? $4
                      : undef # should never get here
                     /sgex;
  
              $p =~ s/\'\'/\'/g;
  
              return $p unless wantarray;
  
              push @r, $p;
          }
  
          return @r;
      }
  
      sub _cldr_pattern {
          my $self    = shift;
          my $pattern = shift;
  
          ## no critic (ControlStructures::ProhibitCStyleForLoops)
          for ( my $i = 0; $i < @patterns; $i += 2 ) {
              if ( $pattern =~ /$patterns[$i]/ ) {
                  my $sub = $patterns[ $i + 1 ];
  
                  return $self->$sub();
              }
          }
  
          return $pattern;
      }
  }
  
  sub _format_nanosecs {
      my $self      = shift;
      my $precision = @_ ? shift : 9;
  
      my $exponent     = 9 - $precision;
      my $formatted_ns = floor(
          (
                $exponent < 0
              ? $self->{rd_nanosecs} * 10**-$exponent
              : $self->{rd_nanosecs} / 10**$exponent
          )
      );
  
      return sprintf(
          '%0' . $precision . 'u',
          $formatted_ns
      );
  }
  
  sub epoch {
      my $self = shift;
  
      return $self->{utc_c}{epoch}
          if exists $self->{utc_c}{epoch};
  
      return $self->{utc_c}{epoch}
          = ( $self->{utc_rd_days} - 719163 ) * SECONDS_PER_DAY
          + $self->{utc_rd_secs};
  }
  
  sub hires_epoch {
      my $self = shift;
  
      my $epoch = $self->epoch;
  
      return undef unless defined $epoch;
  
      my $nano = $self->{rd_nanosecs} / MAX_NANOSECONDS;
  
      return $epoch + $nano;
  }
  
  sub is_finite   {1}
  sub is_infinite {0}
  
  # added for benefit of DateTime::TimeZone
  sub utc_year { $_[0]->{utc_year} }
  
  # returns a result that is relative to the first datetime
  sub subtract_datetime {
      my $dt1 = shift;
      my $dt2 = shift;
  
      $dt2 = $dt2->clone->set_time_zone( $dt1->time_zone )
          unless $dt1->time_zone eq $dt2->time_zone;
  
      # We only want a negative duration if $dt2 > $dt1 ($self)
      my ( $bigger, $smaller, $negative ) = (
          $dt1 >= $dt2
          ? ( $dt1, $dt2, 0 )
          : ( $dt2, $dt1, 1 )
      );
  
      my $is_floating = $dt1->time_zone->is_floating
          && $dt2->time_zone->is_floating;
  
      my $minute_length = 60;
      unless ($is_floating) {
          my ( $utc_rd_days, $utc_rd_secs ) = $smaller->utc_rd_values;
  
          if ( $utc_rd_secs >= 86340 && !$is_floating ) {
  
              # If the smaller of the two datetimes occurs in the last
              # UTC minute of the UTC day, then that minute may not be
              # 60 seconds long. If we need to subtract a minute from
              # the larger datetime's minutes count in order to adjust
              # the seconds difference to be positive, we need to know
              # how long that minute was. If one of the datetimes is
              # floating, we just assume a minute is 60 seconds.
  
              $minute_length = $dt1->_day_length($utc_rd_days) - 86340;
          }
      }
  
      # This is a gross hack that basically figures out if the bigger of
      # the two datetimes is the day of a DST change. If it's a 23 hour
      # day (switching _to_ DST) then we subtract 60 minutes from the
      # local time. If it's a 25 hour day then we add 60 minutes to the
      # local time.
      #
      # This produces the most "intuitive" results, though there are
      # still reversibility problems with the resultant duration.
      #
      # However, if the two objects are on the same (local) date, and we
      # are not crossing a DST change, we don't want to invoke the hack
      # - see 38local-subtract.t
      my $bigger_min = $bigger->hour * 60 + $bigger->minute;
      if (   $bigger->time_zone->has_dst_changes
          && $bigger->is_dst != $smaller->is_dst ) {
  
          $bigger_min -= 60
  
              # it's a 23 hour (local) day
              if (
              $bigger->is_dst
              && do {
                  my $prev_day = try { $bigger->clone->subtract( days => 1 ) };
                  $prev_day && !$prev_day->is_dst ? 1 : 0;
              }
              );
  
          $bigger_min += 60
  
              # it's a 25 hour (local) day
              if (
              !$bigger->is_dst
              && do {
                  my $prev_day = try { $bigger->clone->subtract( days => 1 ) };
                  $prev_day && $prev_day->is_dst ? 1 : 0;
              }
              );
      }
  
      my ( $months, $days, $minutes, $seconds, $nanoseconds )
          = $dt1->_adjust_for_positive_difference(
          $bigger->year * 12 + $bigger->month,
          $smaller->year * 12 + $smaller->month,
  
          $bigger->day, $smaller->day,
  
          $bigger_min, $smaller->hour * 60 + $smaller->minute,
  
          $bigger->second, $smaller->second,
  
          $bigger->nanosecond, $smaller->nanosecond,
  
          $minute_length,
  
          # XXX - using the smaller as the month length is
          # somewhat arbitrary, we could also use the bigger -
          # either way we have reversibility problems
          $dt1->_month_length( $smaller->year, $smaller->month ),
          );
  
      if ($negative) {
          for ( $months, $days, $minutes, $seconds, $nanoseconds ) {
  
              # Some versions of Perl can end up with -0 if we do "0 * -1"!!
              $_ *= -1 if $_;
          }
      }
  
      return $dt1->duration_class->new(
          months      => $months,
          days        => $days,
          minutes     => $minutes,
          seconds     => $seconds,
          nanoseconds => $nanoseconds,
      );
  }
  
  sub _adjust_for_positive_difference
  {    ## no critic (Subroutines::ProhibitManyArgs)
      my (
          $self,
          $month1, $month2,
          $day1,   $day2,
          $min1,   $min2,
          $sec1,   $sec2,
          $nano1,  $nano2,
          $minute_length,
          $month_length,
      ) = @_;
  
      if ( $nano1 < $nano2 ) {
          $sec1--;
          $nano1 += MAX_NANOSECONDS;
      }
  
      if ( $sec1 < $sec2 ) {
          $min1--;
          $sec1 += $minute_length;
      }
  
      # A day always has 24 * 60 minutes, though the minutes may vary in
      # length.
      if ( $min1 < $min2 ) {
          $day1--;
          $min1 += 24 * 60;
      }
  
      if ( $day1 < $day2 ) {
          $month1--;
          $day1 += $month_length;
      }
  
      return (
          $month1 - $month2,
          $day1 - $day2,
          $min1 - $min2,
          $sec1 - $sec2,
          $nano1 - $nano2,
      );
  }
  
  sub subtract_datetime_absolute {
      my $self = shift;
      my $dt   = shift;
  
      my $utc_rd_secs1 = $self->utc_rd_as_seconds;
      $utc_rd_secs1 += $self->_accumulated_leap_seconds( $self->{utc_rd_days} )
          if !$self->time_zone->is_floating;
  
      my $utc_rd_secs2 = $dt->utc_rd_as_seconds;
      $utc_rd_secs2 += $self->_accumulated_leap_seconds( $dt->{utc_rd_days} )
          if !$dt->time_zone->is_floating;
  
      my $seconds     = $utc_rd_secs1 - $utc_rd_secs2;
      my $nanoseconds = $self->nanosecond - $dt->nanosecond;
  
      if ( $nanoseconds < 0 ) {
          $seconds--;
          $nanoseconds += MAX_NANOSECONDS;
      }
  
      return $self->duration_class->new(
          seconds     => $seconds,
          nanoseconds => $nanoseconds,
      );
  }
  
  sub delta_md {
      my $self = shift;
      my $dt   = shift;
  
      my ( $smaller, $bigger ) = sort $self, $dt;
  
      my ( $months, $days, undef, undef, undef )
          = $dt->_adjust_for_positive_difference(
          $bigger->year * 12 + $bigger->month,
          $smaller->year * 12 + $smaller->month,
  
          $bigger->day, $smaller->day,
  
          0, 0,
  
          0, 0,
  
          0, 0,
  
          60,
  
          $smaller->_month_length( $smaller->year, $smaller->month ),
          );
  
      return $self->duration_class->new(
          months => $months,
          days   => $days
      );
  }
  
  sub delta_days {
      my $self = shift;
      my $dt   = shift;
  
      my $days
          = abs( ( $self->local_rd_values )[0] - ( $dt->local_rd_values )[0] );
  
      $self->duration_class->new( days => $days );
  }
  
  sub delta_ms {
      my $self = shift;
      my $dt   = shift;
  
      my ( $smaller, $greater ) = sort $self, $dt;
  
      my $days = int( $greater->jd - $smaller->jd );
  
      my $dur = $greater->subtract_datetime($smaller);
  
      my %p;
      $p{hours}   = $dur->hours + ( $days * 24 );
      $p{minutes} = $dur->minutes;
      $p{seconds} = $dur->seconds;
  
      return $self->duration_class->new(%p);
  }
  
  sub _add_overload {
      my ( $dt, $dur, $reversed ) = @_;
  
      if ($reversed) {
          ( $dur, $dt ) = ( $dt, $dur );
      }
  
      unless ( DateTime::Helpers::isa( $dur, 'DateTime::Duration' ) ) {
          my $class     = ref $dt;
          my $dt_string = overload::StrVal($dt);
  
          Carp::croak( "Cannot add $dur to a $class object ($dt_string).\n"
                  . ' Only a DateTime::Duration object can '
                  . " be added to a $class object." );
      }
  
      return $dt->clone->add_duration($dur);
  }
  
  sub _subtract_overload {
      my ( $date1, $date2, $reversed ) = @_;
  
      if ($reversed) {
          ( $date2, $date1 ) = ( $date1, $date2 );
      }
  
      if ( DateTime::Helpers::isa( $date2, 'DateTime::Duration' ) ) {
          my $new = $date1->clone;
          $new->add_duration( $date2->inverse );
          return $new;
      }
      elsif ( DateTime::Helpers::isa( $date2, 'DateTime' ) ) {
          return $date1->subtract_datetime($date2);
      }
      else {
          my $class     = ref $date1;
          my $dt_string = overload::StrVal($date1);
  
          Carp::croak(
              "Cannot subtract $date2 from a $class object ($dt_string).\n"
                  . ' Only a DateTime::Duration or DateTime object can '
                  . " be subtracted from a $class object." );
      }
  }
  
  sub add {
      my $self = shift;
  
      return $self->add_duration( $self->_duration_object_from_args(@_) );
  }
  
  sub subtract {
      my $self = shift;
  
      my %eom;
      if ( @_ % 2 == 0 ) {
          my %p = @_;
  
          $eom{end_of_month} = delete $p{end_of_month}
              if exists $p{end_of_month};
      }
  
      my $dur = $self->_duration_object_from_args(@_)->inverse(%eom);
  
      return $self->add_duration($dur);
  }
  
  # Syntactic sugar for add and subtract: use a duration object if it's
  # supplied, otherwise build a new one from the arguments.
  
  sub _duration_object_from_args {
      my $self = shift;
  
      return $_[0]
          if @_ == 1 && blessed( $_[0] ) && $_[0]->isa( $self->duration_class );
  
      return $self->duration_class->new(@_);
  }
  
  sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
  
  {
      my $validator = validation_for(
          name             => '_check_add_duration_params',
          name_is_optional => 1,
          params           => [
              { type => t('Duration') },
          ],
      );
  
      ## no critic (Subroutines::ProhibitExcessComplexity)
      sub add_duration {
          my $self = shift;
          my ($dur) = $validator->(@_);
  
          # simple optimization
          return $self if $dur->is_zero;
  
          my %deltas = $dur->deltas;
  
          # This bit isn't quite right since DateTime::Infinite::Future -
          # infinite duration should NaN
          foreach my $val ( values %deltas ) {
              my $inf;
              if ( $val == INFINITY ) {
                  $inf = DateTime::Infinite::Future->new;
              }
              elsif ( $val == NEG_INFINITY ) {
                  $inf = DateTime::Infinite::Past->new;
              }
  
              if ($inf) {
                  %$self = %$inf;
                  bless $self, ref $inf;
  
                  return $self;
              }
          }
  
          return $self if $self->is_infinite;
  
          my %orig = %{$self};
          try {
              $self->_add_duration($dur);
          }
          catch {
              %{$self} = %orig;
              die $_;
          };
      }
  }
  
  sub _add_duration {
      my $self = shift;
      my $dur  = shift;
  
      my %deltas = $dur->deltas;
  
      if ( $deltas{days} ) {
          $self->{local_rd_days} += $deltas{days};
  
          $self->{utc_year} += int( $deltas{days} / 365 ) + 1;
      }
  
      if ( $deltas{months} ) {
  
          # For preserve mode, if it is the last day of the month, make
          # it the 0th day of the following month (which then will
          # normalize back to the last day of the new month).
          my ( $y, $m, $d ) = (
                $dur->is_preserve_mode
              ? $self->_rd2ymd( $self->{local_rd_days} + 1 )
              : $self->_rd2ymd( $self->{local_rd_days} )
          );
  
          $d -= 1 if $dur->is_preserve_mode;
  
          if ( !$dur->is_wrap_mode && $d > 28 ) {
  
              # find the rd for the last day of our target month
              $self->{local_rd_days}
                  = $self->_ymd2rd( $y, $m + $deltas{months} + 1, 0 );
  
              # what day of the month is it? (discard year and month)
              my $last_day
                  = ( $self->_rd2ymd( $self->{local_rd_days} ) )[2];
  
              # if our original day was less than the last day,
              # use that instead
              $self->{local_rd_days} -= $last_day - $d if $last_day > $d;
          }
          else {
              $self->{local_rd_days}
                  = $self->_ymd2rd( $y, $m + $deltas{months}, $d );
          }
  
          $self->{utc_year} += int( $deltas{months} / 12 ) + 1;
      }
  
      if ( $deltas{days} || $deltas{months} ) {
          $self->_calc_utc_rd;
  
          $self->_handle_offset_modifier( $self->second );
      }
  
      if ( $deltas{minutes} ) {
          $self->{utc_rd_secs} += $deltas{minutes} * 60;
  
          # This intentionally ignores leap seconds
          $self->_normalize_tai_seconds(
              $self->{utc_rd_days},
              $self->{utc_rd_secs}
          );
      }
  
      if ( $deltas{seconds} || $deltas{nanoseconds} ) {
          $self->{utc_rd_secs} += $deltas{seconds};
  
          if ( $deltas{nanoseconds} ) {
              $self->{rd_nanosecs} += $deltas{nanoseconds};
              $self->_normalize_nanoseconds(
                  $self->{utc_rd_secs},
                  $self->{rd_nanosecs}
              );
          }
  
          $self->_normalize_seconds;
  
          # This might be some big number much bigger than 60, but
          # that's ok (there are tests in 19leap_second.t to confirm
          # that)
          $self->_handle_offset_modifier( $self->second + $deltas{seconds} );
      }
  
      my $new = ( ref $self )->from_object(
          object => $self,
          locale => $self->{locale},
          ( $self->{formatter} ? ( formatter => $self->{formatter} ) : () ),
      );
  
      %$self = %$new;
  
      return $self;
  }
  
  sub _compare_overload {
  
      # note: $_[1]->compare( $_[0] ) is an error when $_[1] is not a
      # DateTime (such as the INFINITY value)
  
      return undef unless defined $_[1];
  
      return $_[2] ? -$_[0]->compare( $_[1] ) : $_[0]->compare( $_[1] );
  }
  
  sub _string_compare_overload {
      my ( $dt1, $dt2, $flip ) = @_;
  
      # One is a DateTime object, one isn't. Just stringify and compare.
      if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          my $sign = $flip ? -1 : 1;
          return $sign * ( "$dt1" cmp "$dt2" );
      }
      else {
          my $meth = $dt1->can('_compare_overload');
          goto $meth;
      }
  }
  
  sub compare {
      shift->_compare( @_, 0 );
  }
  
  sub compare_ignore_floating {
      shift->_compare( @_, 1 );
  }
  
  sub _compare {
      my ( undef, $dt1, $dt2, $consistent ) = ref $_[0] ? ( undef, @_ ) : @_;
  
      return undef unless defined $dt2;
  
      if ( !ref $dt2 && ( $dt2 == INFINITY || $dt2 == NEG_INFINITY ) ) {
          return $dt1->{utc_rd_days} <=> $dt2;
      }
  
      unless ( DateTime::Helpers::can( $dt1, 'utc_rd_values' )
          && DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          my $dt1_string = overload::StrVal($dt1);
          my $dt2_string = overload::StrVal($dt2);
  
          Carp::croak( 'A DateTime object can only be compared to'
                  . " another DateTime object ($dt1_string, $dt2_string)." );
      }
  
      if (   !$consistent
          && DateTime::Helpers::can( $dt1, 'time_zone' )
          && DateTime::Helpers::can( $dt2, 'time_zone' ) ) {
          my $is_floating1 = $dt1->time_zone->is_floating;
          my $is_floating2 = $dt2->time_zone->is_floating;
  
          if ( $is_floating1 && !$is_floating2 ) {
              $dt1 = $dt1->clone->set_time_zone( $dt2->time_zone );
          }
          elsif ( $is_floating2 && !$is_floating1 ) {
              $dt2 = $dt2->clone->set_time_zone( $dt1->time_zone );
          }
      }
  
      my @dt1_components = $dt1->utc_rd_values;
      my @dt2_components = $dt2->utc_rd_values;
  
      foreach my $i ( 0 .. 2 ) {
          return $dt1_components[$i] <=> $dt2_components[$i]
              if $dt1_components[$i] != $dt2_components[$i];
      }
  
      return 0;
  }
  
  sub is_between {
      my $self  = shift;
      my $lower = shift;
      my $upper = shift;
  
      return $self->compare($lower) > 0 && $self->compare($upper) < 0;
  }
  
  sub _string_equals_overload {
      my ( $class, $dt1, $dt2 ) = ref $_[0] ? ( undef, @_ ) : @_;
  
      if ( !DateTime::Helpers::can( $dt2, 'utc_rd_values' ) ) {
          return "$dt1" eq "$dt2";
      }
  
      $class ||= ref $dt1;
      return !$class->compare( $dt1, $dt2 );
  }
  
  sub _string_not_equals_overload {
      return !_string_equals_overload(@_);
  }
  
  sub _normalize_nanoseconds {
      use integer;
  
      # seconds, nanoseconds
      if ( $_[2] < 0 ) {
          my $overflow = 1 + $_[2] / MAX_NANOSECONDS;
          $_[2] += $overflow * MAX_NANOSECONDS;
          $_[1] -= $overflow;
      }
      elsif ( $_[2] >= MAX_NANOSECONDS ) {
          my $overflow = $_[2] / MAX_NANOSECONDS;
          $_[2] -= $overflow * MAX_NANOSECONDS;
          $_[1] += $overflow;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_set_params',
          name_is_optional => 1,
          params           => {
              year => {
                  type     => t('Year'),
                  optional => 1,
              },
              month => {
                  type     => t('Month'),
                  optional => 1,
              },
              day => {
                  type     => t('DayOfMonth'),
                  optional => 1,
              },
              hour => {
                  type     => t('Hour'),
                  optional => 1,
              },
              minute => {
                  type     => t('Minute'),
                  optional => 1,
              },
              second => {
                  type     => t('Second'),
                  optional => 1,
              },
              nanosecond => {
                  type     => t('Nanosecond'),
                  optional => 1,
              },
              locale => {
                  type     => t('Locale'),
                  optional => 1,
              },
          },
      );
  
      ## no critic (NamingConventions::ProhibitAmbiguousNames)
      sub set {
          my $self = shift;
          my %p    = $validator->(@_);
  
          if ( $p{locale} ) {
              carp 'You passed a locale to the set() method.'
                  . ' You should use set_locale() instead, as using set() may alter the local time near a DST boundary.';
          }
  
          my $new_dt = $self->_new_from_self(%p);
  
          %$self = %$new_dt;
  
          return $self;
      }
  }
  
  sub set_year       { $_[0]->set( year       => $_[1] ) }
  sub set_month      { $_[0]->set( month      => $_[1] ) }
  sub set_day        { $_[0]->set( day        => $_[1] ) }
  sub set_hour       { $_[0]->set( hour       => $_[1] ) }
  sub set_minute     { $_[0]->set( minute     => $_[1] ) }
  sub set_second     { $_[0]->set( second     => $_[1] ) }
  sub set_nanosecond { $_[0]->set( nanosecond => $_[1] ) }
  
  # These two are special cased because ... if the local time is the hour of a
  # DST change where the same local time occurs twice then passing it through
  # _new() can actually change the underlying UTC time, which is bad.
  
  {
      my $validator = validation_for(
          name             => '_check_set_locale_params',
          name_is_optional => 1,
          params           => [
              { type => t( 'Maybe', of => t('Locale') ) },
          ],
      );
  
      sub set_locale {
          my $self = shift;
          my ($locale) = $validator->(@_);
  
          $self->_set_locale($locale);
  
          return $self;
      }
  }
  
  {
      my $validator = validation_for(
          name             => '_check_set_formatter_params',
          name_is_optional => 1,
          params           => [
              { type => t( 'Maybe', of => t('Formatter') ) },
          ],
      );
  
      sub set_formatter {
          my $self = shift;
          my ($formatter) = $validator->(@_);
  
          $self->{formatter} = $formatter;
  
          return $self;
      }
  }
  
  {
      my %TruncateDefault = (
          month      => 1,
          day        => 1,
          hour       => 0,
          minute     => 0,
          second     => 0,
          nanosecond => 0,
      );
  
      my $validator = validation_for(
          name             => '_check_truncate_params',
          name_is_optional => 1,
          params           => {
              to => { type => t('TruncationLevel') },
          },
      );
  
      my $re = join '|', 'year', 'week', 'local_week', 'quarter',
          grep { $_ ne 'nanosecond' } keys %TruncateDefault;
      my $spec = { to => { regex => qr/^(?:$re)$/ } };
  
      ## no critic (Subroutines::ProhibitBuiltinHomonyms)
      sub truncate {
          my $self = shift;
          my %p    = $validator->(@_);
  
          my %new;
          if ( $p{to} eq 'week' || $p{to} eq 'local_week' ) {
              my $first_day_of_week
                  = ( $p{to} eq 'local_week' )
                  ? $self->{locale}->first_day_of_week
                  : 1;
  
              my $day_diff = ( $self->day_of_week - $first_day_of_week ) % 7;
  
              if ($day_diff) {
                  $self->add( days => -1 * $day_diff );
              }
  
              # This can fail if the truncate ends up giving us an invalid local
              # date time. If that happens we need to reverse the addition we
              # just did. See https://rt.cpan.org/Ticket/Display.html?id=93347.
              try {
                  $self->truncate( to => 'day' );
              }
              catch {
                  $self->add( days => $day_diff );
                  die $_;
              };
          }
          elsif ( $p{to} eq 'quarter' ) {
              %new = (
                  year       => $self->year,
                  month      => int( ( $self->month - 1 ) / 3 ) * 3 + 1,
                  day        => 1,
                  hour       => 0,
                  minute     => 0,
                  second     => 0,
                  nanosecond => 0,
              );
          }
          else {
              my $truncate;
              foreach my $f (qw( year month day hour minute second nanosecond ))
              {
                  $new{$f} = $truncate ? $TruncateDefault{$f} : $self->$f();
  
                  $truncate = 1 if $p{to} eq $f;
              }
          }
  
          my $new_dt = $self->_new_from_self( %new, _skip_validation => 1 );
  
          %$self = %$new_dt;
  
          return $self;
      }
  }
  
  sub set_time_zone {
      my ( $self, $tz ) = @_;
  
      if ( ref $tz ) {
  
          # This is a bit of a hack but it works because time zone objects
          # are singletons, and if it doesn't work all we lose is a little
          # bit of speed.
          return $self if $self->{tz} eq $tz;
      }
      else {
          return $self if $self->{tz}->name eq $tz;
      }
  
      my $was_floating = $self->{tz}->is_floating;
  
      my $old_tz = $self->{tz};
      $self->{tz} = ref $tz ? $tz : DateTime::TimeZone->new( name => $tz );
  
      $self->_handle_offset_modifier( $self->second, 1 );
  
      my $e;
      try {
          # if it either was or now is floating (but not both)
          if ( $self->{tz}->is_floating xor $was_floating ) {
              $self->_calc_utc_rd;
          }
          elsif ( !$was_floating ) {
              $self->_calc_local_rd;
          }
      }
      catch {
          $e = $_;
      };
  
      # If we can't recalc the RD values then we shouldn't keep the new TZ. RT
      # #83940
      if ($e) {
          $self->{tz} = $old_tz;
          die $e;
      }
  
      return $self;
  }
  
  sub STORABLE_freeze {
      my $self = shift;
  
      my $serialized = q{};
      foreach my $key (
          qw( utc_rd_days
          utc_rd_secs
          rd_nanosecs )
      ) {
          $serialized .= "$key:$self->{$key}|";
      }
  
      # not used yet, but may be handy in the future.
      $serialized .= 'version:' . ( $DateTime::VERSION || 'git' );
  
      # Formatter needs to be returned as a reference since it may be
      # undef or a class name, and Storable will complain if extra
      # return values aren't refs
      return $serialized, $self->{locale}, $self->{tz}, \$self->{formatter};
  }
  
  sub STORABLE_thaw {
      my $self = shift;
      shift;
      my $serialized = shift;
  
      my %serialized = map { split /:/ } split /\|/, $serialized;
  
      my ( $locale, $tz, $formatter );
  
      # more recent code version
      if (@_) {
          ( $locale, $tz, $formatter ) = @_;
      }
      else {
          $tz = DateTime::TimeZone->new( name => delete $serialized{tz} );
  
          $locale = DateTime::Locale->load( delete $serialized{locale} );
      }
  
      delete $serialized{version};
  
      my $object = bless {
          utc_vals => [
              $serialized{utc_rd_days},
              $serialized{utc_rd_secs},
              $serialized{rd_nanosecs},
          ],
          tz => $tz,
          },
          'DateTime::_Thawed';
  
      my %formatter = defined $$formatter ? ( formatter => $$formatter ) : ();
      my $new       = ( ref $self )->from_object(
          object => $object,
          locale => $locale,
          %formatter,
      );
  
      %$self = %$new;
  
      return $self;
  }
  
  ## no critic (Modules::ProhibitMultiplePackages)
  package    # hide from PAUSE
      DateTime::_Thawed;
  
  sub utc_rd_values { @{ $_[0]->{utc_vals} } }
  
  sub time_zone { $_[0]->{tz} }
  
  1;
  
  # ABSTRACT: A date and time object for Perl
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime - A date and time object for Perl
  
  =head1 VERSION
  
  version 1.54
  
  =head1 SYNOPSIS
  
      use DateTime;
  
      $dt = DateTime->new(
          year       => 1964,
          month      => 10,
          day        => 16,
          hour       => 16,
          minute     => 12,
          second     => 47,
          nanosecond => 500000000,
          time_zone  => 'Asia/Taipei',
      );
  
      $dt = DateTime->from_epoch( epoch => $epoch );
      $dt = DateTime->now;    # same as ( epoch => time )
  
      $year  = $dt->year;
      $month = $dt->month;        # 1-12
  
      $day = $dt->day;            # 1-31
  
      $dow = $dt->day_of_week;    # 1-7 (Monday is 1)
  
      $hour   = $dt->hour;        # 0-23
      $minute = $dt->minute;      # 0-59
  
      $second = $dt->second;      # 0-61 (leap seconds!)
  
      $doy = $dt->day_of_year;    # 1-366 (leap years)
  
      $doq = $dt->day_of_quarter; # 1..
  
      $qtr = $dt->quarter;        # 1-4
  
      # all of the start-at-1 methods above have corresponding start-at-0
      # methods, such as $dt->day_of_month_0, $dt->month_0 and so on
  
      $ymd = $dt->ymd;         # 2002-12-06
      $ymd = $dt->ymd('/');    # 2002/12/06
  
      $mdy = $dt->mdy;         # 12-06-2002
      $mdy = $dt->mdy('/');    # 12/06/2002
  
      $dmy = $dt->dmy;         # 06-12-2002
      $dmy = $dt->dmy('/');    # 06/12/2002
  
      $hms = $dt->hms;         # 14:02:29
      $hms = $dt->hms('!');    # 14!02!29
  
      $is_leap = $dt->is_leap_year;
  
      # these are localizable, see Locales section
      $month_name = $dt->month_name;    # January, February, ...
      $month_abbr = $dt->month_abbr;    # Jan, Feb, ...
      $day_name   = $dt->day_name;      # Monday, Tuesday, ...
      $day_abbr   = $dt->day_abbr;      # Mon, Tue, ...
  
      # May not work for all possible datetime, see the docs on this
      # method for more details.
      $epoch_time = $dt->epoch;
  
      $dt2 = $dt + $duration_object;
  
      $dt3 = $dt - $duration_object;
  
      $duration_object = $dt - $dt2;
  
      $dt->set( year => 1882 );
  
      $dt->set_time_zone('America/Chicago');
  
      $dt->set_formatter($formatter);
  
  =head1 DESCRIPTION
  
  DateTime is a class for the representation of date/time combinations,
  and is part of the Perl DateTime project. For details on this project
  please see L<http://datetime.perl.org/>. The DateTime site has a FAQ
  which may help answer many "how do I do X?" questions. The FAQ is at
  L<http://datetime.perl.org/wiki/datetime/page/FAQ>.
  
  It represents the Gregorian calendar, extended backwards in time
  before its creation (in 1582). This is sometimes known as the
  "proleptic Gregorian calendar". In this calendar, the first day of
  the calendar (the epoch), is the first day of year 1, which
  corresponds to the date which was (incorrectly) believed to be the
  birth of Jesus Christ.
  
  The calendar represented does have a year 0, and in that way differs
  from how dates are often written using "BCE/CE" or "BC/AD".
  
  For infinite datetimes, please see the
  L<DateTime::Infinite|DateTime::Infinite> module.
  
  =head1 USAGE
  
  =head2 0-based Versus 1-based Numbers
  
  The C<DateTime> module follows a simple logic for determining whether or not a
  given number is 0-based or 1-based.
  
  Month, day of month, day of week, and day of year are 1-based. Any
  method that is 1-based also has an equivalent 0-based method ending in
  C<_0>. So for example, this class provides both C<day_of_week> and
  C<day_of_week_0> methods.
  
  The C<day_of_week_0> method still treats Monday as the first day of
  the week.
  
  All I<time>-related numbers such as hour, minute, and second are
  0-based.
  
  Years are neither, as they can be both positive or negative, unlike
  any other datetime component. There I<is> a year 0.
  
  There is no C<quarter_0> method.
  
  =head2 Error Handling
  
  Some errors may cause this module to die with an error string. This
  can only happen when calling constructor methods, methods that change
  the object, such as C<set>, or methods that take parameters.
  Methods that retrieve information about the object, such as C<year>
  or C<epoch>, will never die.
  
  =head2 Locales
  
  All the object methods which return names or abbreviations return data based
  on a locale. This is done by setting the locale when constructing a DateTime
  object. If this is not set, then C<"en-US"> is used.
  
  =head2 Floating DateTimes
  
  The default time zone for new DateTime objects, except where stated
  otherwise, is the "floating" time zone. This concept comes from the
  iCal standard. A floating datetime is one which is not anchored to
  any particular time zone. In addition, floating datetimes do not
  include leap seconds, since we cannot apply them without knowing the
  datetime's time zone.
  
  The results of date math and comparison between a floating datetime
  and one with a real time zone are not really valid, because one
  includes leap seconds and the other does not. Similarly, the results
  of datetime math between two floating datetimes and two datetimes with
  time zones are not really comparable.
  
  If you are planning to use any objects with a real time zone, it is
  strongly recommended that you B<do not> mix these with floating
  datetimes.
  
  =head2 Math
  
  If you are going to be doing date math, please read the section L<How DateTime
  Math Works>.
  
  =head2 Determining the Local Time Zone Can Be Slow
  
  If C<$ENV{TZ}> is not set, it may involve reading a number of files in F</etc>
  or elsewhere. If you know that the local time zone won't change while your
  code is running, and you need to make many objects for the local time zone, it
  is strongly recommended that you retrieve the local time zone once and cache
  it:
  
      our $App::LocalTZ = DateTime::TimeZone->new( name => 'local' );
  
      # then everywhere else
  
      my $dt = DateTime->new( ..., time_zone => $App::LocalTZ );
  
  DateTime itself does not do this internally because local time zones can
  change, and there's no good way to determine if it's changed without doing all
  the work to look it up.
  
  =head2 Far Future DST
  
  Do not try to use named time zones (like "America/Chicago") with dates
  very far in the future (thousands of years). The current
  implementation of C<DateTime::TimeZone> will use a huge amount of
  memory calculating all the DST changes from now until the future
  date. Use UTC or the floating time zone and you will be safe.
  
  =head2 Globally Setting a Default Time Zone
  
  B<Warning: This is very dangerous. Do this at your own risk!>
  
  By default, C<DateTime> uses either the floating time zone or UTC for newly
  created objects, depending on the constructor.
  
  You can force C<DateTime> to use a different time zone by setting the
  C<PERL_DATETIME_DEFAULT_TZ> environment variable.
  
  As noted above, this is very dangerous, as it affects all code that creates a
  C<DateTime> object, including modules from CPAN. If those modules expect the
  normal default, then setting this can cause confusing breakage or subtly
  broken data. Before setting this variable, you are strongly encouraged to
  audit your CPAN dependencies to see how they use C<DateTime>. Try running the
  test suite for each dependency with this environment variable set before using
  this in production.
  
  =head2 Upper and Lower Bounds
  
  Internally, dates are represented the number of days before or after
  0001-01-01. This is stored as an integer, meaning that the upper and lower
  bounds are based on your Perl's integer size (C<$Config{ivsize}>).
  
  The limit on 32-bit systems is around 2^29 days, which gets you to year
  (+/-)1,469,903. On a 64-bit system you get 2^62 days, to year
  (+/-)12,626,367,463,883,278 (12.626 quadrillion).
  
  =head1 METHODS
  
  DateTime provides many methods. The documentation breaks them down into groups
  based on what they do (constructor, accessors, modifiers, etc.).
  
  =head2 Constructors
  
  All constructors can die when invalid parameters are given.
  
  =head3 Warnings
  
  Currently, constructors will warn if you try to create a far future DateTime
  (year >= 5000) with any time zone besides floating or UTC. This can be very
  slow if the time zone has future DST transitions that need to be
  calculated. If the date is sufficiently far in the future this can be
  I<really> slow (minutes).
  
  All warnings from DateTime use the C<DateTime> category and can be suppressed
  with:
  
      no warnings 'DateTime';
  
  This warning may be removed in the future if L<DateTime::TimeZone> is made
  much faster.
  
  =head3 DateTime->new( ... )
  
      my $dt = DateTime->new(
          year       => 1966,
          month      => 10,
          day        => 25,
          hour       => 7,
          minute     => 15,
          second     => 47,
          nanosecond => 500000000,
          time_zone  => 'America/Chicago',
      );
  
  This class method accepts the following parameters:
  
  =over 4
  
  =item * year
  
  An integer year for the DateTime. This can be any integer number within the
  valid range for your system (See L</Upper and Lower Bounds>). This is
  required.
  
  =item * month
  
  An integer from 1-12. Defaults to 1.
  
  =item * day
  
  An integer from 1-31. The value will be validated based on the month, to
  prevent creating invalid dates like February 30. Defaults to 1.
  
  =item * hour
  
  An integer from 0-23. Hour 0 is midnight at the beginning of the given date.
  Defaults to 0.
  
  =item * minute
  
  An integer from 0-59. Defaults to 0.
  
  =item * second
  
  An integer from 0-61. Values of 60 or 61 are only allowed when the specified
  date and time have a leap second. Defaults to 0.
  
  =item * nanosecond
  
  An integer that is greater than or equal to 0. If this number is greater than
  1 billion, it will be normalized into the second value for the DateTime
  object. Defaults to 0
  
  =item * locale
  
  A string containing a locale code, like C<"en-US"> or C<"zh-Hant-TW">, or an
  object returned by C<< DateTime::Locale->load >>. See the L<DateTime::Locale>
  documentation for details. Defaults to the value of C<<
  DateTime->DefaultLocale >>, or C<"en-US"> if the class default has not been
  set.
  
  =item * time_zone
  
  A string containing a time zone name like "America/Chicago" or a
  L<DateTime::TimeZone> object. Defaults to the value of
  C<$ENV{PERL_DATETIME_DEFAULT_TZ}> or "floating" if that env var is not
  set. See L</Globally Setting a Default Time Zone> for more details on that env
  var (and why you should not use it).
  
  A string will simply be passed to the C<< DateTime::TimeZone->new >> method as
  its C<name> parameter. This string may be an Olson DB time zone name
  ("America/Chicago"), an offset string ("+0630"), or the words "floating" or
  "local". See the C<DateTime::TimeZone> documentation for more details.
  
  =item * formatter
  
  An object or class name with a C<format_datetime> method. This will be used to
  stringify the DateTime object. This is optional. If it is not specified, then
  stringification calls C<< $self->iso8601 >>.
  
  =back
  
  Invalid parameter types (like an array reference) will cause the constructor
  to die.
  
  =head4 Parsing Dates
  
  B<This module does not parse dates!> That means there is no
  constructor to which you can pass things like "March 3, 1970 12:34".
  
  Instead, take a look at the various
  L<DateTime::Format::*|https://metacpan.org/search?q=datetime%3A%3Aformat>
  modules on CPAN. These parse all sorts of different date formats, and you're
  bound to find something that can handle your particular needs.
  
  =head4 Ambiguous Local Times
  
  Because of Daylight Saving Time, it is possible to specify a local
  time that is ambiguous. For example, in the US in 2003, the
  transition from to saving to standard time occurred on October 26, at
  02:00:00 local time. The local clock changed from 01:59:59 (saving
  time) to 01:00:00 (standard time). This means that the hour from
  01:00:00 through 01:59:59 actually occurs twice, though the UTC time
  continues to move forward.
  
  If you specify an ambiguous time, then the latest UTC time is always
  used, in effect always choosing standard time. In this case, you can
  simply subtract an hour from the object in order to move to saving time,
  for example:
  
      # This object represent 01:30:00 standard time
      my $dt = DateTime->new(
          year      => 2003,
          month     => 10,
          day       => 26,
          hour      => 1,
          minute    => 30,
          second    => 0,
          time_zone => 'America/Chicago',
      );
  
      print $dt->hms;    # prints 01:30:00
  
      # Now the object represent 01:30:00 saving time
      $dt->subtract( hours => 1 );
  
      print $dt->hms;    # still prints 01:30:00
  
  Alternately, you could create the object with the UTC time zone and
  then call the C<set_time_zone> method to change the time zone. This
  is a good way to ensure that the time is not ambiguous.
  
  =head4 Invalid Local Times
  
  Another problem introduced by Daylight Saving Time is that certain
  local times just do not exist. For example, in the US in 2003, the
  transition from standard to saving time occurred on April 6, at the
  change to 2:00:00 local time. The local clock changed from 01:59:59
  (standard time) to 03:00:00 (saving time). This means that there is
  no 02:00:00 through 02:59:59 on April 6!
  
  Attempting to create an invalid time currently causes a fatal error.
  
  =head3 DateTime->from_epoch( epoch => $epoch, ... )
  
  This class method can be used to construct a new DateTime object from
  an epoch time instead of components. Just as with the C<new>
  method, it accepts C<time_zone>, C<locale>, and C<formatter> parameters.
  
  If the epoch value is a non-integral value, it will be rounded to nearest
  microsecond.
  
  By default, the returned object will be in the UTC time zone.
  
  =head3 DateTime->now( ... )
  
  This class method is equivalent to calling C<from_epoch> with the
  value returned from Perl's C<time> function. Just as with the
  C<new> method, it accepts C<time_zone> and C<locale> parameters.
  
  By default, the returned object will be in the UTC time zone.
  
  If you want sub-second resolution, use the L<DateTime::HiRes> module's C<<
  DateTime::HiRes->now >> method instead.
  
  =head3 DateTime->today( ... )
  
  This class method is equivalent to:
  
      DateTime->now(@_)->truncate( to => 'day' );
  
  =head3 DateTime->last_day_of_month( ... )
  
  This constructor takes the same arguments as can be given to the
  C<new> method, except for C<day>. Additionally, both C<year> and
  C<month> are required.
  
  =head3 DateTime->from_day_of_year( ... )
  
  This constructor takes the same arguments as can be given to the
  C<new> method, except that it does not accept a C<month> or C<day>
  argument. Instead, it requires both C<year> and C<day_of_year>. The
  day of year must be between 1 and 366, and 366 is only allowed for
  leap years.
  
  =head3 DateTime->from_object( object => $object, ... )
  
  This class method can be used to construct a new DateTime object from
  any object that implements the C<utc_rd_values> method. All
  C<DateTime::Calendar> modules must implement this method in order to
  provide cross-calendar compatibility. This method accepts a
  C<locale> and C<formatter> parameter
  
  If the object passed to this method has a C<time_zone> method, that is used to
  set the time zone of the newly created C<DateTime> object.
  
  Otherwise, the returned object will be in the floating time zone.
  
  =head3 $dt->clone
  
  This object method returns a new object that is replica of the object
  upon which the method is called.
  
  =head2 "Get" Methods
  
  This class has many methods for retrieving information about an
  object.
  
  =head3 $dt->year
  
  Returns the year.
  
  =head3 $dt->ce_year
  
  Returns the year according to the BCE/CE numbering system. The year
  before year 1 in this system is year -1, aka "1 BCE".
  
  =head3 $dt->era_name
  
  Returns the long name of the current era, something like "Before
  Christ". See the L</Locales> section for more details.
  
  =head3 $dt->era_abbr
  
  Returns the abbreviated name of the current era, something like "BC".
  See the L</Locales> section for more details.
  
  =head3 $dt->christian_era
  
  Returns a string, either "BC" or "AD", according to the year.
  
  =head3 $dt->secular_era
  
  Returns a string, either "BCE" or "CE", according to the year.
  
  =head3 $dt->year_with_era
  
  Returns a string containing the year immediately followed by the appropriate
  era abbreviation, based on the object's locale. The year is the absolute value
  of C<ce_year>, so that year 1 is "1" and year 0 is "1BC". See the L</Locales>
  section for more details.
  
  =head3 $dt->year_with_christian_era
  
  Like C<year_with_era>, but uses the C<christian_era> method to get the era
  name.
  
  =head3 $dt->year_with_secular_era
  
  Like C<year_with_era>, but uses the C<secular_era> method to get the
  era name.
  
  =head3 $dt->month
  
  Returns the month of the year, from 1..12.
  
  Also available as C<< $dt->mon >>.
  
  =head3 $dt->month_name
  
  Returns the name of the current month. See the L</Locales> section for more
  details.
  
  =head3 $dt->month_abbr
  
  Returns the abbreviated name of the current month. See the L</Locales> section
  for more details.
  
  =head3 $dt->day
  
  Returns the day of the month, from 1..31.
  
  Also available as C<< $dt->mday >> and C<< $dt->day_of_month >>.
  
  =head3 $dt->day_of_week
  
  Returns the day of the week as a number, from 1..7, with 1 being
  Monday and 7 being Sunday.
  
  Also available as C<< $dt->wday >> and C<< $dt->dow >>.
  
  =head3 $dt->local_day_of_week
  
  Returns the day of the week as a number, from 1..7. The day corresponding to 1
  will vary based on the locale. See the L</Locales> section for more details.
  
  =head3 $dt->day_name
  
  Returns the name of the current day of the week. See the L</Locales> section
  for more details.
  
  =head3 $dt->day_abbr
  
  Returns the abbreviated name of the current day of the week. See the
  L</Locales> section for more details.
  
  =head3 $dt->day_of_year
  
  Returns the day of the year.
  
  Also available as C<< $dt->doy >>.
  
  =head3 $dt->quarter
  
  Returns the quarter of the year, from 1..4.
  
  =head3 $dt->quarter_name
  
  Returns the name of the current quarter. See the L</Locales> section for more
  details.
  
  =head3 $dt->quarter_abbr
  
  Returns the abbreviated name of the current quarter. See the L</Locales>
  section for more details.
  
  =head3 $dt->day_of_quarter
  
  Returns the day of the quarter.
  
  Also available as C<< $dt->doq >>.
  
  =head3 $dt->weekday_of_month
  
  Returns a number from 1..5 indicating which week day of the month this
  is. For example, June 9, 2003 is the second Monday of the month, and
  so this method returns 2 for that date.
  
  =head3 $dt->ymd($optional_separator), $dt->mdy(...), $dt->dmy(...)
  
  Each method returns the year, month, and day, in the order indicated
  by the method name. Years are zero-padded to four digits. Months and
  days are 0-padded to two digits.
  
  By default, the values are separated by a dash (-), but this can be
  overridden by passing a value to the method.
  
  The C<< $dt->ymd >> method is also available as C<< $dt->date >>.
  
  =head3 $dt->hour
  
  Returns the hour of the day, from 0..23.
  
  =head3 $dt->hour_1
  
  Returns the hour of the day, from 1..24.
  
  =head3 $dt->hour_12
  
  Returns the hour of the day, from 1..12.
  
  =head3 $dt->hour_12_0
  
  Returns the hour of the day, from 0..11.
  
  =head3 $dt->am_or_pm
  
  Returns the appropriate localized abbreviation, depending on the
  current hour.
  
  =head3 $dt->minute
  
  Returns the minute of the hour, from 0..59.
  
  Also available as C<< $dt->min >>.
  
  =head3 $dt->second
  
  Returns the second, from 0..61. The values 60 and 61 are used for
  leap seconds.
  
  Also available as C<< $dt->sec >>.
  
  =head3 $dt->fractional_second
  
  Returns the second, as a real number from 0.0 until 61.999999999
  
  The values 60 and 61 are used for leap seconds.
  
  =head3 $dt->millisecond
  
  Returns the fractional part of the second as milliseconds (1E-3 seconds).
  
  Half a second is 500 milliseconds.
  
  This value will always be rounded down to the nearest integer.
  
  =head3 $dt->microsecond
  
  Returns the fractional part of the second as microseconds (1E-6
  seconds).
  
  Half a second is 500,000 microseconds.
  
  This value will always be rounded down to the nearest integer.
  
  =head3 $dt->nanosecond
  
  Returns the fractional part of the second as nanoseconds (1E-9 seconds).
  
   Half a second is 500,000,000 nanoseconds.
  
  =head3 $dt->hms($optional_separator)
  
  Returns the hour, minute, and second, all zero-padded to two digits.
  If no separator is specified, a colon (:) is used by default.
  
  Also available as C<< $dt->time >>.
  
  =head3 $dt->datetime($optional_separator)
  
  This method is equivalent to:
  
      $dt->ymd('-') . 'T' . $dt->hms(':')
  
  The C<$optional_separator> parameter allows you to override the separator
  between the date and time, for e.g. C<< $dt->datetime(q{ }) >>.
  
  This method is also available as C<< $dt->iso8601 >>, but it's not really a
  very good ISO8601 format, as it lacks a time zone. If called as C<<
  $dt->iso8601 >> you cannot change the separator, as ISO8601 specifies that "T"
  must be used to separate them.
  
  =head3 $dt->rfc3339
  
  This formats a datetime in RFC3339 format. This is the same as C<<
  $dt->datetime >> with an added offset at the end of the string except if the
  time zone is the floating time zone.
  
  If the offset is '+00:00' then this is represented as 'Z'. Otherwise the
  offset is formatted with a leading sign (+/-) and a colon separated numeric
  offset with hours and minutes. If the offset has a non-zero seconds component,
  that is also included.
  
  =head3 $dt->stringify
  
  This method returns a stringified version of the object. It is also how
  stringification overloading is implemented. If the object has a formatter,
  then its C<format_datetime> method is used to produce a string. Otherwise,
  this method calls C<< $dt->iso8601 >> to produce a string. See L</Formatters
  And Stringification> for details.
  
  =head3 $dt->is_leap_year
  
  This method returns a boolean value indicating whether or not the datetime
  object is in a leap year.
  
  =head3 $dt->is_last_day_of_month
  
  This method returns a boolean value indicating whether or not the datetime
  object is the last day of the month.
  
  =head3 $dt->is_last_day_of_quarter
  
  This method returns a boolean value indicating whether or not the datetime
  object is the last day of the quarter.
  
  =head3 $dt->is_last_day_of_year
  
  This method returns a boolean value indicating whether or not the datetime
  object is the last day of the year.
  
  =head3 $dt->month_length
  
  This method returns the number of days in the current month.
  
  =head3 $dt->quarter_length
  
  This method returns the number of days in the current quarter.
  
  =head3 $dt->year_length
  
  This method returns the number of days in the current year.
  
  =head3 $dt->week
  
     my ( $week_year, $week_number ) = $dt->week;
  
  Returns information about the calendar week for the date. The values returned
  by this method are also available separately through the C<< $dt->week_year >>
  and C<< $dt->week_number >> methods.
  
  The first week of the year is defined by ISO as the one which contains
  the fourth day of January, which is equivalent to saying that it's the
  first week to overlap the new year by at least four days.
  
  Typically the week year will be the same as the year that the object
  is in, but dates at the very beginning of a calendar year often end up
  in the last week of the prior year, and similarly, the final few days
  of the year may be placed in the first week of the next year.
  
  =head3 $dt->week_year
  
  Returns the year of the week. See C<< $dt->week >> for details.
  
  =head3 $dt->week_number
  
  Returns the week of the year, from 1..53. See C<< $dt->week >> for details.
  
  =head3 $dt->week_of_month
  
  The week of the month, from 0..5. The first week of the month is the
  first week that contains a Thursday. This is based on the ICU
  definition of week of month, and correlates to the ISO8601 week of
  year definition. A day in the week I<before> the week with the first
  Thursday will be week 0.
  
  =head3 $dt->jd, $dt->mjd
  
  These return the Julian Day and Modified Julian Day, respectively.
  The value returned is a floating point number. The fractional portion
  of the number represents the time portion of the datetime.
  
  The Julian Day is a count of days since the beginning of the Julian Period,
  which starts with day 0 at noon on January 1, -4712.
  
  The Modified Julian Day is a count of days since midnight on November 17,
  1858.
  
  These methods always refer to the local time, so the Julian Day is the same
  for a given datetime regardless of its time zone. Or in other words,
  2020-12-04T13:01:57 in "America/Chicago" has the same Julian Day as
  2020-12-04T13:01:57 in "Asia/Taipei".
  
  =head3 $dt->time_zone
  
  This returns the L<DateTime::TimeZone> object for the datetime object.
  
  =head3 $dt->offset
  
  This returns the offset from UTC, in seconds, of the datetime object's time
  zone.
  
  =head3 $dt->is_dst
  
  Returns a boolean indicating whether or not the datetime's time zone is
  currently in Daylight Saving Time or not.
  
  =head3 $dt->time_zone_long_name
  
  This is a shortcut for C<< $dt->time_zone->name >>. It's provided so
  that one can use "%{time_zone_long_name}" as a strftime format
  specifier.
  
  =head3 $dt->time_zone_short_name
  
  This method returns the time zone abbreviation for the current time zone, such
  as "PST" or "GMT". These names are B<not> definitive, and should not be used
  in any application intended for general use by users around the world. That's
  because it's possible for multiple time zones to have the same abbreviation.
  
  =head3 $dt->strftime( $format, ... )
  
  This method implements functionality similar to the C<strftime>
  method in C. However, if given multiple format strings, then it will
  return multiple scalars, one for each format string.
  
  See the L<strftime Patterns> section for a list of all possible
  strftime patterns.
  
  If you give a pattern that doesn't exist, then it is simply treated as
  text.
  
  Note that any deviation from the POSIX standard is probably a bug. DateTime
  should match the output of C<POSIX::strftime> for any given pattern.
  
  =head3 $dt->format_cldr( $format, ... )
  
  This method implements formatting based on the CLDR date patterns. If
  given multiple format strings, then it will return multiple scalars,
  one for each format string.
  
  See the L<CLDR Patterns> section for a list of all possible CLDR
  patterns.
  
  If you give a pattern that doesn't exist, then it is simply treated as
  text.
  
  =head3 $dt->epoch
  
  Returns the UTC epoch value for the datetime object. Datetimes before the
  start of the epoch will be returned as a negative number.
  
  The return value from this method is always an integer number of seconds.
  
  Since the epoch does not account for leap seconds, the epoch time for
  1972-12-31T23:59:60 (UTC) is exactly the same as that for
  1973-01-01T00:00:00.
  
  =head3 $dt->hires_epoch
  
  Returns the epoch as a floating point number. The floating point
  portion of the value represents the nanosecond value of the object.
  This method is provided for compatibility with the C<Time::HiRes>
  module.
  
  Note that this method suffers from the imprecision of floating point numbers,
  and the result may end up rounded to an arbitrary degree depending on your
  platform.
  
      my $dt = DateTime->new( year => 2012, nanosecond => 4 );
      say $dt->hires_epoch;
  
  On my system, this simply prints C<1325376000> because adding C<0.000000004>
  to C<1325376000> returns C<1325376000>.
  
  =head3 $dt->is_finite, $dt->is_infinite
  
  These methods allow you to distinguish normal datetime objects from infinite
  ones. Infinite datetime objects are documented in L<DateTime::Infinite>.
  
  =head3 $dt->utc_rd_values
  
  Returns the current UTC Rata Die days, seconds, and nanoseconds as a
  three element list. This exists primarily to allow other calendar
  modules to create objects based on the values provided by this object.
  
  =head3 $dt->local_rd_values
  
  Returns the current local Rata Die days, seconds, and nanoseconds as a
  three element list. This exists for the benefit of other modules
  which might want to use this information for date math, such as
  L<DateTime::Event::Recurrence>.
  
  =head3 $dt->leap_seconds
  
  Returns the number of leap seconds that have happened up to the
  datetime represented by the object. For floating datetimes, this
  always returns 0.
  
  =head3 $dt->utc_rd_as_seconds
  
  Returns the current UTC Rata Die days and seconds purely as seconds.
  This number ignores any fractional seconds stored in the object,
  as well as leap seconds.
  
  =head3 $dt->locale
  
  Returns the datetime's L<DateTime::Locale> object.
  
  =head3 $dt->formatter
  
  Returns the current formatter object or class. See L<Formatters And
  Stringification> for details.
  
  =head2 "Set" Methods
  
  The remaining methods provided by C<DateTime>, except where otherwise
  specified, return the object itself, thus making method chaining possible. For
  example:
  
      my $dt = DateTime->now->set_time_zone( 'Australia/Sydney' );
  
      my $first = DateTime
                      ->last_day_of_month( year => 2003, month => 3 )
                      ->add( days => 1 )
                      ->subtract( seconds => 1 );
  
  =head3 $dt->set( .. )
  
  This method can be used to change the local components of a date time. This
  method accepts any parameter allowed by the C<new> method except for
  C<locale> or C<time_zone>. Use C<set_locale> and C<set_time_zone> for those
  instead.
  
  This method performs parameter validation just like the C<new> method.
  
  B<Do not use this method to do date math. Use the C<add> and C<subtract>
  methods instead.>
  
  =head3 $dt->set_year, $dt->set_month, etc.
  
  DateTime has a C<set_*> method for every item that can be passed to the
  constructor:
  
  =over 4
  
  =item * $dt->set_year
  
  =item * $dt->set_month
  
  =item * $dt->set_day
  
  =item * $dt->set_hour
  
  =item * $dt->set_minute
  
  =item * $dt->set_second
  
  =item * $dt->set_nanosecond
  
  =back
  
  These are shortcuts to calling C<set> with a single key. They all
  take a single parameter.
  
  =head3 $dt->truncate( to => ... )
  
  This method allows you to reset some of the local time components in the
  object to their "zero" values. The C<to> parameter is used to specify which
  values to truncate, and it may be one of C<"year">, C<"quarter">, C<"month">,
  C<"week">, C<"local_week">, C<"day">, C<"hour">, C<"minute">, or C<"second">.
  
  For example, if C<"month"> is specified, then the local day becomes 1, and the
  hour, minute, and second all become 0.
  
  If C<"week"> is given, then the datetime is set to the Monday of the week in
  which it occurs, and the time components are all set to 0. If you truncate to
  C<"local_week">, then the first day of the week is locale-dependent. For
  example, in the C<"en-US"> locale, the first day of the week is Sunday.
  
  =head3 $dt->set_locale($locale)
  
  Sets the object's locale. You can provide either a locale code like C<"en-US">
  or an object returned by C<< DateTime::Locale->load >>.
  
  =head3 $dt->set_time_zone($tz)
  
  This method accepts either a time zone object or a string that can be passed
  as the C<name> parameter to C<< DateTime::TimeZone->new >>. If the new time
  zone's offset is different from the old time zone, then the I<local> time is
  adjusted accordingly.
  
  For example:
  
      my $dt = DateTime->new(
          year      => 2000,
          month     => 5,
          day       => 10,
          hour      => 15,
          minute    => 15,
          time_zone => 'America/Los_Angeles',
      );
  
      print $dt->hour;    # prints 15
  
      $dt->set_time_zone('America/Chicago');
  
      print $dt->hour;    # prints 17
  
  If the old time zone was a floating time zone, then no adjustments to
  the local time are made, except to account for leap seconds. If the
  new time zone is floating, then the I<UTC> time is adjusted in order
  to leave the local time untouched.
  
  Fans of Tsai Ming-Liang's films will be happy to know that this does
  work:
  
      my $dt = DateTime->now( time_zone => 'Asia/Taipei' );
      $dt->set_time_zone('Europe/Paris');
  
  Yes, now we can know "ni3 na4 bian1 ji2 dian3?"
  
  =head3 $dt->set_formatter($formatter)
  
  Sets the formatter for the object. See L<Formatters And Stringification> for
  details.
  
  You can set this to C<undef> to revert to the default formatter.
  
  =head2 Math Methods
  
  Like the set methods, math related methods always return the object
  itself, to allow for chaining:
  
      $dt->add( days => 1 )->subtract( seconds => 1 );
  
  =head3 $dt->duration_class
  
  This returns L<C<"DateTime::Duration">|DateTime::Duration>, but exists so that
  a subclass of C<DateTime> can provide a different value.
  
  =head3 $dt->add_duration($duration_object)
  
  This method adds a L<DateTime::Duration> to the current datetime. See the
  L<DateTime::Duration> docs for more details.
  
  =head3 $dt->add( parameters for DateTime::Duration )
  
  This method is syntactic sugar around the C<< $dt->add_duration >> method. It
  simply creates a new L<DateTime::Duration> object using the parameters given,
  and then calls the C<< $dt->add_duration >> method.
  
  =head3 $dt->add($duration_object)
  
  A synonym of C<< $dt->add_duration($duration_object) >>.
  
  =head3 $dt->subtract_duration($duration_object)
  
  When given a L<DateTime::Duration> object, this method simply calls C<<
  $dur->inverse >> on that object and passes that new duration to the C<<
  $self->add_duration >> method.
  
  =head3 $dt->subtract( DateTime::Duration->new parameters )
  
  Like C<< $dt->add >>, this is syntactic sugar for the C<<
  $dt->subtract_duration >> method.
  
  =head3 $dt->subtract($duration_object)
  
  A synonym of C<< $dt->subtract_duration($duration_object) >>.
  
  =head3 $dt->subtract_datetime($datetime)
  
  This method returns a new L<DateTime::Duration> object representing
  the difference between the two dates. The duration is B<relative> to
  the object from which C<$datetime> is subtracted. For example:
  
      2003-03-15 00:00:00.00000000
   -  2003-02-15 00:00:00.00000000
   -------------------------------
   = 1 month
  
  Note that this duration is not an absolute measure of the amount of
  time between the two datetimes, because the length of a month varies,
  as well as due to the presence of leap seconds.
  
  The returned duration may have deltas for months, days, minutes,
  seconds, and nanoseconds.
  
  =head3 $dt->delta_md($datetime)
  
  =head3 $dt->delta_days($datetime)
  
  Each of these methods returns a new L<DateTime::Duration> object representing
  some portion of the difference between two datetimes.  The C<< $dt->delta_md
  >> method returns a duration which contains only the month and day portions of
  the duration is represented. The C<< $dt->delta_days >> method returns a
  duration which contains only days.
  
  The C<< $dt->delta_md >> and C<< $dt->delta_days >> methods truncate the
  duration so that any fractional portion of a day is ignored. Both of these
  methods operate on the date portion of a datetime only, and so effectively
  ignore the time zone.
  
  Unlike the subtraction methods, B<these methods always return a positive (or
  zero) duration>.
  
  =head3 $dt->delta_ms($datetime)
  
  Returns a duration which contains only minutes and seconds. Any day and month
  differences are converted to minutes and seconds. This method B<always returns
  a positive (or zero) duration>.
  
  =head3 $dt->subtract_datetime_absolute($datetime)
  
  This method returns a new L<DateTime::Duration> object representing the
  difference between the two dates in seconds and nanoseconds. This is the only
  way to accurately measure the absolute amount of time between two datetimes,
  since units larger than a second do not represent a fixed number of seconds.
  
  Note that because of leap seconds, this may not return the same result as
  doing this math based on the value returned by C<< $dt->epoch >>.
  
  =head3 $dt->is_between( $lower, $upper )
  
  Checks whether C<$dt> is strictly between two other DateTime objects.
  
  "Strictly" means that C<$dt> must be greater than C<$lower> and less than
  C<$upper>. If it is I<equal> to either object then this method returns false.
  
  =head2 Class Methods
  
  =head3 DateTime->DefaultLocale($locale)
  
  This can be used to specify the default locale to be used when creating
  DateTime objects. If unset, then C<"en-US"> is used.
  
  This exists for backwards compatibility, but is probably best avoided. This
  will change the default locale for every C<DateTime> object created in your
  application, even those created by third party libraries which also use
  C<DateTime>.
  
  =head3 DateTime->compare( $dt1, $dt2 ), DateTime->compare_ignore_floating( $dt1, $dt2 )
  
      $cmp = DateTime->compare( $dt1, $dt2 );
  
      $cmp = DateTime->compare_ignore_floating( $dt1, $dt2 );
  
  This method compare two DateTime objects. The semantics are compatible with
  Perl's C<sort> function; it returns C<-1> if C<< $dt1 < $dt2 >>, C<0> if
  C<$dt1 == $dt2>, C<1> if C<< $dt1 > $dt2 >>.
  
  If one of the two DateTime objects has a floating time zone, it will
  first be converted to the time zone of the other object. This is what
  you want most of the time, but it can lead to inconsistent results
  when you compare a number of DateTime objects, some of which are
  floating, and some of which are in other time zones.
  
  If you want to have consistent results (because you want to sort an array of
  objects, for example), you can use the C<compare_ignore_floating> method:
  
      @dates = sort { DateTime->compare_ignore_floating( $a, $b ) } @dates;
  
  In this case, objects with a floating time zone will be sorted as if
  they were UTC times.
  
  Since DateTime objects overload comparison operators, this:
  
      @dates = sort @dates;
  
  is equivalent to this:
  
      @dates = sort { DateTime->compare( $a, $b ) } @dates;
  
  DateTime objects can be compared to any other calendar class that implements
  the C<utc_rd_values> method.
  
  =head2 Testing Code That Uses DateTime
  
  If you are trying to test code that calls uses DateTime, you may want to be to
  explicitly set the value returned by Perl's C<time> builtin. This builtin is
  called by C<< DateTime->now >> and C<< DateTime->today >>.
  
  You can override C<CORE::GLOBAL::time>, but this will only work if you do this
  B<before> loading DateTime. If doing this is inconvenient, you can also
  override C<DateTime::_core_time>:
  
      no warnings 'redefine';
      local *DateTime::_core_time = sub { return 42 };
  
  DateTime is guaranteed to call this subroutine to get the current C<time>
  value. You can also override the C<_core_time> sub in a subclass of DateTime
  and use that.
  
  =head2 How DateTime Math Works
  
  It's important to have some understanding of how datetime math is implemented
  in order to effectively use this module and L<DateTime::Duration>.
  
  =head3 Making Things Simple
  
  If you want to simplify your life and not have to think too hard about
  the nitty-gritty of datetime math, I have several recommendations:
  
  =over 4
  
  =item * use the floating time zone
  
  If you do not care about time zones or leap seconds, use the
  "floating" timezone:
  
      my $dt = DateTime->now( time_zone => 'floating' );
  
  Math done on two objects in the floating time zone produces very
  predictable results.
  
  Note that in most cases you will want to start by creating an object in a
  specific zone and I<then> convert it to the floating time zone. When an object
  goes from a real zone to the floating zone, the time for the object remains
  the same.
  
  This means that passing the floating zone to a constructor may not do what you
  want.
  
      my $dt = DateTime->now( time_zone => 'floating' );
  
  is equivalent to
  
      my $dt = DateTime->now( time_zone => 'UTC' )->set_time_zone('floating');
  
  This might not be what you wanted. Instead, you may prefer to do this:
  
      my $dt = DateTime->now( time_zone => 'local' )->set_time_zone('floating');
  
  =item * use UTC for all calculations
  
  If you do care about time zones (particularly DST) or leap seconds,
  try to use non-UTC time zones for presentation and user input only.
  Convert to UTC immediately and convert back to the local time zone for
  presentation:
  
      my $dt = DateTime->new( %user_input, time_zone => $user_tz );
      $dt->set_time_zone('UTC');
  
      # do various operations - store it, retrieve it, add, subtract, etc.
  
      $dt->set_time_zone($user_tz);
      print $dt->datetime;
  
  =item * math on non-UTC time zones
  
  If you need to do date math on objects with non-UTC time zones, please read
  the caveats below carefully. The results C<DateTime> produces are predictable,
  correct, and mostly intuitive, but datetime math gets very ugly when time
  zones are involved, and there are a few strange corner cases involving
  subtraction of two datetimes across a DST change.
  
  If you can always use the floating or UTC time zones, you can skip ahead to
  L<Leap Seconds and Date Math>
  
  =item * date vs datetime math
  
  If you only care about the date (calendar) portion of a datetime, you should
  use either C<< $dt->delta_md >>> or C<< $dt->delta_days >>, not C<<
  $dt->subtract_datetime >>. This will give predictable, unsurprising results,
  free from DST-related complications.
  
  =item * $dt->subtract_datetime and $dt->add_duration
  
  You must convert your datetime objects to the UTC time zone before
  doing date math if you want to make sure that the following formulas
  are always true:
  
      $dt2 - $dt1 = $dur
      $dt1 + $dur = $dt2
      $dt2 - $dur = $dt1
  
  Note that using C<< $dt->delta_days >> ensures that this formula always works,
  regardless of the time zones of the objects involved, as does using C<<
  $dt->subtract_datetime_absolute >>. Other methods of subtraction are not
  always reversible.
  
  =item * never do math on two objects where only one is in the floating time zone
  
  The date math code accounts for leap seconds whenever the C<DateTime> object
  is not in the floating time zone. If you try to do math where one object is in
  the floating zone and the other isn't, the results will be confusing and
  wrong.
  
  =back
  
  =head3 Adding a Duration to a DateTime
  
  The parts of a duration can be broken down into five parts. These are months,
  days, minutes, seconds, and nanoseconds. Adding one month to a date is
  different than adding 4 weeks or 28, 29, 30, or 31 days.  Similarly, due to
  DST and leap seconds, adding a day can be different than adding 86,400
  seconds, and adding a minute is not exactly the same as 60 seconds.
  
  We cannot convert between these units, except for seconds and nanoseconds,
  because there is no fixed conversion between most pairs of units. That is
  because of things like leap seconds, DST changes, etc.
  
  C<DateTime> always adds (or subtracts) days, then months, minutes, and then
  seconds and nanoseconds. If there are any boundary overflows, these are
  normalized at each step. For the days and months the local (not UTC) values
  are used. For minutes and seconds, the local values are used. This generally
  just works.
  
  This means that adding one month and one day to February 28, 2003 will
  produce the date April 1, 2003, not March 29, 2003.
  
      my $dt = DateTime->new( year => 2003, month => 2, day => 28 );
  
      $dt->add( months => 1, days => 1 );
  
      # 2003-04-01 - the result
  
  On the other hand, if we add months first, and then separately add
  days, we end up with March 29, 2003:
  
      $dt->add( months => 1 )->add( days => 1 );
  
      # 2003-03-29
  
  We see similar strangeness when math crosses a DST boundary:
  
      my $dt = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 1,
          minute    => 58,
          time_zone => "America/Chicago",
      );
  
      $dt->add( days => 1, minutes => 3 );
      # 2003-04-06 02:01:00
  
      $dt->add( minutes => 3 )->add( days => 1 );
      # 2003-04-06 03:01:00
  
  Note that if you converted the datetime object to UTC first you would
  get predictable results.
  
  If you want to know how many seconds a L<DateTime::Duration> object
  represents, you have to add it to a datetime to find out, so you could do:
  
      my $now   = DateTime->now( time_zone => 'UTC' );
      my $later = $now->clone->add_duration($duration);
  
      my $seconds_dur = $later->subtract_datetime_absolute($now);
  
  This returns a L<DateTime::Duration> which only contains seconds and
  nanoseconds.
  
  If we were add the duration to a different C<DateTime> object we might get a
  different number of seconds.
  
  L<DateTime::Duration> supports three different end-of-month algorithms for
  adding months. This comes into play when an addition results in a day past the
  end of the following month (for example, adding one month to January 30).
  
      # 2010-08-31 + 1 month = 2010-10-01
      $dt->add( months => 1, end_of_month => 'wrap' );
  
      # 2010-01-30 + 1 month = 2010-02-28
      $dt->add( months => 1, end_of_month => 'limit' );
  
      # 2010-04-30 + 1 month = 2010-05-31
      $dt->add( months => 1, end_of_month => 'preserve' );
  
  By default, it uses C<"wrap"> for positive durations and C<"preserve"> for
  negative durations. See L<DateTime::Duration> for a detailed explanation of
  these algorithms.
  
  If you need to do lots of work with durations, take a look at the
  L<DateTime::Format::Duration> module, which lets you present information from
  durations in many useful ways.
  
  There are other subtract/delta methods in C<DateTime> to generate different
  types of durations. These methods are C<< $dt->subtract_datetime >>, C<<
  $dt->subtract_datetime_absolute >>, C<< $dt->delta_md >>, C<< $dt->delta_days
  >>, and C<< $dt->delta_ms >>.
  
  =head3 DateTime Subtraction
  
  Date subtraction is done based solely on the two object's local datetimes,
  with one exception to handle DST changes. Also, if the two datetime objects
  are in different time zones, one of them is converted to the other's time zone
  first before subtraction. This is best explained through examples:
  
  The first of these probably makes the most sense:
  
      # not DST
      my $dt1 = DateTime->new(
          year      => 2003,
          month     => 5,
          day       => 6,
          time_zone => 'America/Chicago',
      );
  
      # is DST
      my $dt2 = DateTime->new(
          year      => 2003,
          month     => 11,
          day       => 6,
          time_zone => 'America/Chicago',
      );
  
      # 6 months
      my $dur = $dt2->subtract_datetime($dt1);
  
  Nice and simple.
  
  This one is a little trickier, but still fairly logical:
  
      # is DST
      my $dt1 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 1,
          minute    => 58,
          time_zone => "America/Chicago",
      );
  
      # not DST
      my $dt2 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 7,
          hour      => 2,
          minute    => 1,
          time_zone => "America/Chicago",
      );
  
      # 2 days and 3 minutes
      my $dur = $dt2->subtract_datetime($dt1);
  
  Which contradicts the result this one gives, even though they both
  make sense:
  
      # is DST
      my $dt1 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 1,
          minute    => 58,
          time_zone => "America/Chicago",
      );
  
      # not DST
      my $dt2 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 6,
          hour      => 3,
          minute    => 1,
          time_zone => "America/Chicago",
      );
  
      # 1 day and 3 minutes
      my $dur = $dt2->subtract_datetime($dt1);
  
  This last example illustrates the "DST" exception mentioned earlier. The
  exception accounts for the fact 2003-04-06 only lasts 23 hours.
  
  And finally:
  
      my $dt2 = DateTime->new(
          year      => 2003,
          month     => 10,
          day       => 26,
          hour      => 1,
          time_zone => 'America/Chicago',
      );
  
      my $dt1 = $dt2->clone->subtract( hours => 1 );
  
      # 60 minutes
      my $dur = $dt2->subtract_datetime($dt1);
  
  This seems obvious until you realize that subtracting 60 minutes from C<$dt2>
  in the above example still leaves the clock time at "01:00:00". This time we
  are accounting for a 25 hour day.
  
  =head3 Reversibility
  
  Date math operations are not always reversible. This is because of the way
  that addition operations are ordered. As was discussed earlier, adding 1 day
  and 3 minutes in one call to C<< $dt->add >>> is not the same as first adding
  3 minutes and 1 day in two separate calls.
  
  If we take a duration returned from C<< $dt->subtract_datetime >> and then try
  to add or subtract that duration from one of the datetimes we just used, we
  sometimes get interesting results:
  
      my $dt1 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 1,
          minute    => 58,
          time_zone => "America/Chicago",
      );
  
      my $dt2 = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 6,
          hour      => 3,
          minute    => 1,
          time_zone => "America/Chicago",
      );
  
      # 1 day and 3 minutes
      my $dur = $dt2->subtract_datetime($dt1);
  
      # gives us $dt2
      $dt1->add_duration($dur);
  
      # gives us 2003-04-05 02:58:00 - 1 hour later than $dt1
      $dt2->subtract_duration($dur);
  
  The C<< $dt->subtract_duration >> operation gives us a (perhaps) unexpected
  answer because it first subtracts one day to get 2003-04-05T03:01:00
  and then subtracts 3 minutes to get the final result.
  
  If we explicitly reverse the order we can get the original value of
  C<$dt1>. This can be facilitated by the L<DateTime::Duration> class's C<<
  $dur->calendar_duration >> and C<< $dur->clock_duration >> methods:
  
      $dt2->subtract_duration( $dur->clock_duration )
          ->subtract_duration( $dur->calendar_duration );
  
  =head3 Leap Seconds and Date Math
  
  The presence of leap seconds can cause even more anomalies in date
  math. For example, the following is a legal datetime:
  
      my $dt = DateTime->new(
          year      => 1972,
          month     => 12,
          day       => 31,
          hour      => 23,
          minute    => 59,
          second    => 60,
          time_zone => 'UTC'
      );
  
  If we add one month ...
  
      $dt->add( months => 1 );
  
  ... the datetime is now "1973-02-01 00:00:00", because there is no 23:59:60 on
  1973-01-31.
  
  Leap seconds also force us to distinguish between minutes and seconds
  during date math. Given the following datetime ...
  
      my $dt = DateTime->new(
          year      => 1972,
          month     => 12,
          day       => 31,
          hour      => 23,
          minute    => 59,
          second    => 30,
          time_zone => 'UTC'
      );
  
  ... we will get different results when adding 1 minute than we get if we add
  60 seconds. This is because in this case, the last minute of the day,
  beginning at 23:59:00, actually contains 61 seconds.
  
  Here are the results we get:
  
      # 1972-12-31 23:59:30 - our starting datetime
      my $dt = DateTime->new(
          year      => 1972,
          month     => 12,
          day       => 31,
          hour      => 23,
          minute    => 59,
          second    => 30,
          time_zone => 'UTC'
      );
  
      # 1973-01-01 00:00:30 - one minute later
      $dt->clone->add( minutes => 1 );
  
      # 1973-01-01 00:00:29 - 60 seconds later
      $dt->clone->add( seconds => 60 );
  
      # 1973-01-01 00:00:30 - 61 seconds later
      $dt->clone->add( seconds => 61 );
  
  =head3 Local vs. UTC and 24 hours vs. 1 day
  
  When math crosses a daylight saving boundary, a single day may have
  more or less than 24 hours.
  
  For example, if you do this ...
  
      my $dt = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 2,
          time_zone => 'America/Chicago',
      );
  
      $dt->add( days => 1 );
  
  ... then you will produce an I<invalid> local time, and therefore an exception
  will be thrown.
  
  However, this works ...
  
      my $dt = DateTime->new(
          year      => 2003,
          month     => 4,
          day       => 5,
          hour      => 2,
          time_zone => 'America/Chicago',
      );
  
      $dt->add( hours => 24 );
  
  ... and produces a datetime with the local time of "03:00".
  
  If all this makes your head hurt, there is a simple alternative. Just convert
  your datetime object to the "UTC" time zone before doing date math on it, and
  switch it back to the local time zone afterwards. This avoids the possibility
  of having date math throw an exception, and makes sure that 1 day equals 24
  hours. Of course, this may not always be desirable, so caveat user!
  
  =head2 Overloading
  
  This module explicitly overloads the addition (+), subtraction (-), string and
  numeric comparison operators. This means that the following all do sensible
  things:
  
      my $new_dt = $dt + $duration_obj;
  
      my $new_dt = $dt - $duration_obj;
  
      my $duration_obj = $dt - $new_dt;
  
      foreach my $dt ( sort @dts ) {...}
  
  Additionally, the fallback parameter is set to true, so other
  derivable operators (+=, -=, etc.) will work properly. Do not expect
  increment (++) or decrement (--) to do anything useful.
  
  The string comparison operators, C<eq> or C<ne>, will use the string
  value to compare with non-DateTime objects.
  
  DateTime objects do not have a numeric value, using C<==> or C<< <=>
  >> to compare a DateTime object with a non-DateTime object will result
  in an exception. To safely sort mixed DateTime and non-DateTime
  objects, use C<sort { $a cmp $b } @dates>.
  
  The module also overloads stringification using the object's
  formatter, defaulting to C<iso8601> method. See L<Formatters And
  Stringification> for details.
  
  =head2 Formatters And Stringification
  
  You can optionally specify a C<formatter>, which is usually a
  C<DateTime::Format::*> object or class, to control the stringification of the
  DateTime object.
  
  Any of the constructor methods can accept a formatter argument:
  
      my $formatter = DateTime::Format::Strptime->new(...);
      my $dt        = DateTime->new( year => 2004, formatter => $formatter );
  
  Or, you can set it afterwards:
  
      $dt->set_formatter($formatter);
      $formatter = $dt->formatter;
  
  Once you set the formatter, the overloaded stringification method will
  use the formatter. If unspecified, the C<iso8601> method is used.
  
  A formatter can be handy when you know that in your application you
  want to stringify your DateTime objects into a special format all the
  time, for example in Postgres format.
  
  If you provide a formatter class name or object, it must implement a
  C<format_datetime> method. This method will be called with just the
  C<DateTime> object as its argument.
  
  =head2 CLDR Patterns
  
  The CLDR pattern language is both more powerful and more complex than
  strftime. Unlike strftime patterns, you often have to explicitly
  escape text that you do not want formatted, as the patterns are simply
  letters without any prefix.
  
  For example, C<"yyyy-MM-dd"> is a valid CLDR pattern. If you want to include
  any lower or upper case ASCII characters as-is, you can surround them with
  single quotes ('). If you want to include a single quote, you must escape it
  as two single quotes ('').
  
      my $pattern1 = q{'Today is ' EEEE};
      my $pattern2 = q{'It is now' h 'o''clock' a};
  
  Spaces and any non-letter text will always be passed through as-is.
  
  Many CLDR patterns which produce numbers will pad the number with leading
  zeroes depending on the length of the format specifier. For example, C<"h">
  represents the current hour from 1-12. If you specify C<"hh"> then hours 1-9
  will have a leading zero prepended.
  
  However, CLDR often uses five of a letter to represent the narrow form
  of a pattern. This inconsistency is necessary for backwards
  compatibility.
  
  There are many cases where CLDR patterns distinguish between the "format" and
  "stand-alone" forms of a pattern. The format pattern is used when the thing in
  question is being placed into a larger string. The stand-alone form is used
  when displaying that item by itself, for example in a calendar.
  
  There are also many cases where CLDR provides three sizes for each item, wide
  (the full name), abbreviated, and narrow. The narrow form is often just a
  single character, for example "T" for "Tuesday", and may not be unique.
  
  CLDR provides a fairly complex system for localizing time zones that
  we ignore entirely. The time zone patterns just use the information
  provided by C<DateTime::TimeZone>, and I<do not follow the CLDR spec>.
  
  The output of a CLDR pattern is always localized, when applicable.
  
  CLDR provides the following patterns:
  
  =over 4
  
  =item * G{1,3}
  
  The abbreviated era (BC, AD).
  
  =item * GGGG
  
  The wide era (Before Christ, Anno Domini).
  
  =item * GGGGG
  
  The narrow era, if it exists (but it mostly doesn't).
  
  =item * y and y{3,}
  
  The year, zero-prefixed as needed. Negative years will start with a "-",
  and this will be included in the length calculation.
  
  In other, words the "yyyyy" pattern will format year -1234 as "-1234", not
  "-01234".
  
  =item * yy
  
  This is a special case. It always produces a two-digit year, so "1976" becomes
  "76". Negative years will start with a "-", making them one character longer.
  
  =item * Y{1,}
  
  The year in "week of the year" calendars, from C<< $dt->week_year >>.
  
  =item * u{1,}
  
  Same as "y" except that "uu" is not a special case.
  
  =item * Q{1,2}
  
  The quarter as a number (1..4).
  
  =item * QQQ
  
  The abbreviated format form for the quarter.
  
  =item * QQQQ
  
  The wide format form for the quarter.
  
  =item * q{1,2}
  
  The quarter as a number (1..4).
  
  =item * qqq
  
  The abbreviated stand-alone form for the quarter.
  
  =item * qqqq
  
  The wide stand-alone form for the quarter.
  
  =item * M{1,2]
  
  The numerical month.
  
  =item * MMM
  
  The abbreviated format form for the month.
  
  =item * MMMM
  
  The wide format form for the month.
  
  =item * MMMMM
  
  The narrow format form for the month.
  
  =item * L{1,2]
  
  The numerical month.
  
  =item * LLL
  
  The abbreviated stand-alone form for the month.
  
  =item * LLLL
  
  The wide stand-alone form for the month.
  
  =item * LLLLL
  
  The narrow stand-alone form for the month.
  
  =item * w{1,2}
  
  The week of the year, from C<< $dt->week_number >>.
  
  =item * W
  
  The week of the month, from C<< $dt->week_of_month >>.
  
  =item * d{1,2}
  
  The numeric day of the month.
  
  =item * D{1,3}
  
  The numeric day of the year.
  
  =item * F
  
  The day of the week in the month, from C<< $dt->weekday_of_month >>.
  
  =item * g{1,}
  
  The modified Julian day, from C<< $dt->mjd >>.
  
  =item * E{1,3} and eee
  
  The abbreviated format form for the day of the week.
  
  =item * EEEE and eeee
  
  The wide format form for the day of the week.
  
  =item * EEEEE and eeeee
  
  The narrow format form for the day of the week.
  
  =item * e{1,2}
  
  The I<local> numeric day of the week, from 1 to 7. This number depends
  on what day is considered the first day of the week, which varies by
  locale. For example, in the US, Sunday is the first day of the week,
  so this returns 2 for Monday.
  
  =item * c
  
  The numeric day of the week from 1 to 7, treating Monday as the first
  of the week, regardless of locale.
  
  =item * ccc
  
  The abbreviated stand-alone form for the day of the week.
  
  =item * cccc
  
  The wide stand-alone form for the day of the week.
  
  =item * ccccc
  
  The narrow format form for the day of the week.
  
  =item * a
  
  The localized form of AM or PM for the time.
  
  =item * h{1,2}
  
  The hour from 1-12.
  
  =item * H{1,2}
  
  The hour from 0-23.
  
  =item * K{1,2}
  
  The hour from 0-11.
  
  =item * k{1,2}
  
  The hour from 1-24.
  
  =item * j{1,2}
  
  The hour, in 12 or 24 hour form, based on the preferred form for the
  locale. In other words, this is equivalent to either "h{1,2}" or
  "H{1,2}".
  
  =item * m{1,2}
  
  The minute.
  
  =item * s{1,2}
  
  The second.
  
  =item * S{1,}
  
  The fractional portion of the seconds, rounded based on the length of
  the specifier. This returned I<without> a leading decimal point, but
  may have leading or trailing zeroes.
  
  =item * A{1,}
  
  The millisecond of the day, based on the current time. In other words,
  if it is 12:00:00.00, this returns 43200000.
  
  =item * z{1,3}
  
  The time zone short name.
  
  =item * zzzz
  
  The time zone long name.
  
  =item * Z{1,3}
  
  The time zone offset.
  
  =item * ZZZZ
  
  The time zone short name and the offset as one string, so something
  like "CDT-0500".
  
  =item * ZZZZZ
  
  The time zone offset as a sexagesimal number, so something like "-05:00".
  (This is useful for W3C format.)
  
  =item * v{1,3}
  
  The time zone short name.
  
  =item * vvvv
  
  The time zone long name.
  
  =item * V{1,3}
  
  The time zone short name.
  
  =item * VVVV
  
  The time zone long name.
  
  =back
  
  =head3 CLDR "Available Formats"
  
  The CLDR data includes pre-defined formats for various patterns such as "month
  and day" or "time of day". Using these formats lets you render information
  about a datetime in the most natural way for users from a given locale.
  
  These formats are indexed by a key that is itself a CLDR pattern. When you
  look these up, you get back a different CLDR pattern suitable for the locale.
  
  Let's look at some example We'll use C<2008-02-05T18:30:30> as our example
  datetime value, and see how this is rendered for the C<"en-US"> and C<"fr-FR">
  locales.
  
  =over 4
  
  =item * C<MMMd>
  
  The abbreviated month and day as number. For C<en-US>, we get the pattern
  C<MMM d>, which renders as C<Feb 5>. For C<fr-FR>, we get the pattern
  C<d MMM>, which renders as C<5 févr.>.
  
  =item * C<yQQQ>
  
  The year and abbreviated quarter of year. For C<en-US>, we get the pattern
  C<QQQ y>, which renders as C<Q1 2008>. For C<fr-FR>, we get the same pattern,
  C<QQQ y>, which renders as C<T1 2008>.
  
  =item * C<hm>
  
  The 12-hour time of day without seconds. For C<en-US>, we get the pattern
  C<h:mm a>, which renders as C<6:30 PM>. For C<fr-FR>, we get the exact same
  pattern and rendering.
  
  =back
  
  The available formats for each locale are documented in the POD for that
  locale. To get back the format, you use the C<< $locale->format_for >>
  method. For example:
  
      say $dt->format_cldr( $dt->locale->format_for('MMMd') );
  
  =head2 strftime Patterns
  
  The following patterns are allowed in the format string given to the
  C<< $dt->strftime >> method:
  
  =over 4
  
  =item * %a
  
  The abbreviated weekday name.
  
  =item * %A
  
  The full weekday name.
  
  =item * %b
  
  The abbreviated month name.
  
  =item * %B
  
  The full month name.
  
  =item * %c
  
  The default datetime format for the object's locale.
  
  =item * %C
  
  The century number (year/100) as a 2-digit integer.
  
  =item * %d
  
  The day of the month as a decimal number (range 01 to 31).
  
  =item * %D
  
  Equivalent to %m/%d/%y. This is not a good standard format if you
  want folks from both the United States and the rest of the world to
  understand the date!
  
  =item * %e
  
  Like %d, the day of the month as a decimal number, but a leading zero
  is replaced by a space.
  
  =item * %F
  
  Equivalent to %Y-%m-%d (the ISO 8601 date format)
  
  =item * %G
  
  The ISO 8601 year with century as a decimal number. The 4-digit year
  corresponding to the ISO week number (see %V). This has the same
  format and value as %Y, except that if the ISO week number belongs to
  the previous or next year, that year is used instead. (TZ)
  
  =item * %g
  
  Like %G, but without century, i.e., with a 2-digit year (00-99).
  
  =item * %h
  
  Equivalent to %b.
  
  =item * %H
  
  The hour as a decimal number using a 24-hour clock (range 00 to 23).
  
  =item * %I
  
  The hour as a decimal number using a 12-hour clock (range 01 to 12).
  
  =item * %j
  
  The day of the year as a decimal number (range 001 to 366).
  
  =item * %k
  
  The hour (24-hour clock) as a decimal number (range 0 to 23); single
  digits are preceded by a blank. (See also %H.)
  
  =item * %l
  
  The hour (12-hour clock) as a decimal number (range 1 to 12); single
  digits are preceded by a blank. (See also %I.)
  
  =item * %m
  
  The month as a decimal number (range 01 to 12).
  
  =item * %M
  
  The minute as a decimal number (range 00 to 59).
  
  =item * %n
  
  A newline character.
  
  =item * %N
  
  The fractional seconds digits. Default is 9 digits (nanoseconds).
  
      %3N   milliseconds (3 digits)
      %6N   microseconds (6 digits)
      %9N   nanoseconds  (9 digits)
  
  This value will always be rounded down to the nearest integer.
  
  =item * %p
  
  Either `AM' or `PM' according to the given time value, or the
  corresponding strings for the current locale. Noon is treated as `pm'
  and midnight as `am'.
  
  =item * %P
  
  Like %p but in lowercase: `am' or `pm' or a corresponding string for
  the current locale.
  
  =item * %r
  
  The time in a.m. or p.m. notation. In the POSIX locale this is
  equivalent to `%I:%M:%S %p'.
  
  =item * %R
  
  The time in 24-hour notation (%H:%M). (SU) For a version including the
  seconds, see %T below.
  
  =item * %s
  
  The number of seconds since the epoch.
  
  =item * %S
  
  The second as a decimal number (range 00 to 61).
  
  =item * %t
  
  A tab character.
  
  =item * %T
  
  The time in 24-hour notation (%H:%M:%S).
  
  =item * %u
  
  The day of the week as a decimal, range 1 to 7, Monday being 1. See
  also %w.
  
  =item * %U
  
  The week number of the current year as a decimal number, range 00 to
  53, starting with the first Sunday as the first day of week 01. See
  also %V and %W.
  
  =item * %V
  
  The ISO 8601:1988 week number of the current year as a decimal number,
  range 01 to 53, where week 1 is the first week that has at least 4
  days in the current year, and with Monday as the first day of the
  week. See also %U and %W.
  
  =item * %w
  
  The day of the week as a decimal, range 0 to 6, Sunday being 0. See
  also %u.
  
  =item * %W
  
  The week number of the current year as a decimal number, range 00 to
  53, starting with the first Monday as the first day of week 01.
  
  =item * %x
  
  The default date format for the object's locale.
  
  =item * %X
  
  The default time format for the object's locale.
  
  =item * %y
  
  The year as a decimal number without a century (range 00 to 99).
  
  =item * %Y
  
  The year as a decimal number including the century.
  
  =item * %z
  
  The time-zone as hour offset from UTC. Required to emit
  RFC822-conformant dates (using "%a, %d %b %Y %H:%M:%S %z").
  
  =item * %Z
  
  The short name for the time zone, typically an abbreviation like "EST" or
  "AEST".
  
  =item * %%
  
  A literal `%' character.
  
  =item * %{method}
  
  Any method name may be specified using the format C<%{method}> name where
  "method" is a valid C<DateTime> object method.
  
  =back
  
  =head2 DateTime and Storable
  
  C<DateTime> implements L<Storable> hooks in order to reduce the size of a
  serialized C<DateTime> object.
  
  =head1 THE DATETIME PROJECT ECOSYSTEM
  
  This module is part of a larger ecosystem of modules in the DateTime
  family.
  
  =head2 L<DateTime::Set>
  
  The L<DateTime::Set> module represents sets (including recurrences) of
  datetimes. Many modules return sets or recurrences.
  
  =head2 Format Modules
  
  The various format modules exist to parse and format datetimes. For example,
  L<DateTime::Format::HTTP> parses dates according to the RFC 1123 format:
  
      my $datetime
          = DateTime::Format::HTTP->parse_datetime(
          'Thu Feb  3 17:03:55 GMT 1994');
  
      print DateTime::Format::HTTP->format_datetime($datetime);
  
  Most format modules are suitable for use as a C<formatter> with a DateTime
  object.
  
  All format modules start with
  L<DateTime::Format::|https://metacpan.org/search?q=datetime%3A%3Aformat>.
  
  =head2 Calendar Modules
  
  There are a number of modules on CPAN that implement non-Gregorian calendars,
  such as the Chinese, Mayan, and Julian calendars.
  
  All calendar modules start with
  L<DateTime::Calendar::|https://metacpan.org/search?q=datetime%3A%3Acalendar>.
  
  =head2 Event Modules
  
  There are a number of modules that calculate the dates for events, such as
  Easter, Sunrise, etc.
  
  All event modules start with
  L<DateTime::Event::|https://metacpan.org/search?q=datetime%3A%3Aevent>.
  
  =head2 Others
  
  There are many other modules that work with DateTime, including modules in the
  L<DateTimeX namespace|https://metacpan.org/search?q=datetimex> namespace, as
  well as others.
  
  See L<MetaCPAN|https://metacpan.org/search?q=datetime> for more modules.
  
  =head1 KNOWN BUGS
  
  The tests in F<20infinite.t> seem to fail on some machines,
  particularly on Win32. This appears to be related to Perl's internal
  handling of IEEE infinity and NaN, and seems to be highly
  platform/compiler/phase of moon dependent.
  
  If you don't plan to use infinite datetimes you can probably ignore
  this. This will be fixed (perhaps) in future versions.
  
  =head1 SEE ALSO
  
  L<A Date with
  Perl|http://www.houseabsolute.com/presentations/a-date-with-perl/> - a talk
  I've given at a few YAPCs.
  
  L<datetime@perl.org mailing list|http://lists.perl.org/list/datetime.html>
  
  L<http://datetime.perl.org/>
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module, please
  consider making a "donation" to me via PayPal. I spend a lot of free time
  creating free software, and would appreciate any support you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order for me
  to continue working on this particular software. I will continue to do so,
  inasmuch as I have in the past, for as long as it interests me.
  
  Similarly, a donation made in this way will probably not make me work on this
  software much more, unless I get so many donations that I can consider working
  on free software full time (let's all have a chuckle at that together).
  
  To donate, log into PayPal and send money to autarch@urth.org, or use the
  button at L<https://www.urth.org/fs-donation.html>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Ben Bennett Christian Hansen Daisuke Maki Dan Book Stewart David E. Wheeler Precious Doug Bell Flávio Soibelmann Glock Gianni Ceccarelli Gregory Oschwald Hauke D Iain Truskett Jason McIntosh Joshua Hoblitt Karen Etheridge Mark Overmeer Michael Conrad R. Davis Mohammad S Anwar M Somerville Nick Tonkin Olaf Alders Ovid Paul Howarth Philippe Bruhat (BooK) philip r brenan Ricardo Signes Richard Bowen Ron Hill Sam Kington viviparous
  
  =over 4
  
  =item *
  
  Ben Bennett <fiji@limey.net>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  Daisuke Maki <dmaki@cpan.org>
  
  =item *
  
  Dan Book <grinnz@gmail.com>
  
  =item *
  
  Dan Stewart <danielandrewstewart@gmail.com>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  David Precious <davidp@preshweb.co.uk>
  
  =item *
  
  Doug Bell <madcityzen@gmail.com>
  
  =item *
  
  Flávio Soibelmann Glock <fglock@gmail.com>
  
  =item *
  
  Gianni Ceccarelli <gianni.ceccarelli@broadbean.com>
  
  =item *
  
  Gregory Oschwald <oschwald@gmail.com>
  
  =item *
  
  Hauke D <haukex@zero-g.net>
  
  =item *
  
  Iain Truskett <deceased>
  
  =item *
  
  Jason McIntosh <jmac@jmac.org>
  
  =item *
  
  Joshua Hoblitt <jhoblitt@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Mark Overmeer <mark@overmeer.net>
  
  =item *
  
  Michael Conrad <mike@nrdvana.net>
  
  =item *
  
  Michael R. Davis <mrdvt92@users.noreply.github.com>
  
  =item *
  
  Mohammad S Anwar <mohammad.anwar@yahoo.com>
  
  =item *
  
  M Somerville <dracos@users.noreply.github.com>
  
  =item *
  
  Nick Tonkin <1nickt@users.noreply.github.com>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Ovid <curtis_ovid_poe@yahoo.com>
  
  =item *
  
  Paul Howarth <paul@city-fan.org>
  
  =item *
  
  Philippe Bruhat (BooK) <book@cpan.org>
  
  =item *
  
  philip r brenan <philiprbrenan@gmail.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Richard Bowen <bowen@cpan.org>
  
  =item *
  
  Ron Hill <rkhill@cpan.org>
  
  =item *
  
  Sam Kington <github@illuminated.co.uk>
  
  =item *
  
  viviparous <viviparous@prc>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2020 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PERL5_DATETIME

$fatpacked{"perl5/DateTime/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_CONFLICTS';
  package # hide from PAUSE
      DateTime::Conflicts;
  
  use strict;
  use warnings;
  
  # this module was generated with Dist::Zilla::Plugin::Conflicts 0.19
  
  use Dist::CheckConflicts
      -dist      => 'DateTime',
      -conflicts => {
          'DateTime::Format::Mail' => '0.402',
      },
      -also => [ qw(
          Carp
          DateTime::Locale
          DateTime::TimeZone
          Dist::CheckConflicts
          POSIX
          Params::ValidationCompiler
          Scalar::Util
          Specio
          Specio::Declare
          Specio::Exporter
          Specio::Library::Builtins
          Specio::Library::Numeric
          Specio::Library::String
          Try::Tiny
          XSLoader
          base
          integer
          namespace::autoclean
          overload
          parent
          strict
          warnings
          warnings::register
      ) ],
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for DateTime
  # Dist::Zilla: -PodWeaver
PERL5_DATETIME_CONFLICTS

$fatpacked{"perl5/DateTime/Duration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_DURATION';
  package DateTime::Duration;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.54';
  
  use Carp ();
  use DateTime;
  use DateTime::Helpers;
  use DateTime::Types;
  use Params::ValidationCompiler 0.26 qw( validation_for );
  use Scalar::Util qw( blessed );
  
  use overload (
      fallback => 1,
      '+'      => '_add_overload',
      '-'      => '_subtract_overload',
      '*'      => '_multiply_overload',
      '<=>'    => '_compare_overload',
      'cmp'    => '_compare_overload',
  );
  
  sub MAX_NANOSECONDS () {1_000_000_000}    # 1E9 = almost 32 bits
  
  my @all_units = qw( months days minutes seconds nanoseconds );
  
  {
      my %units = map {
          $_ => {
  
              # XXX - what we really want is to accept an integer, Inf, -Inf,
              # and NaN, but I can't figure out how to accept NaN since it never
              # compares to anything.
              type    => t('Defined'),
              default => 0,
          }
          } qw(
          years
          months
          weeks
          days
          hours
          minutes
          seconds
          nanoseconds
      );
  
      my $check = validation_for(
          name             => '_check_new_params',
          name_is_optional => 1,
          params           => {
              %units,
              end_of_month => {
                  type     => t('EndOfMonthMode'),
                  optional => 1,
              },
          },
      );
  
      sub new {
          my $class = shift;
          my %p     = $check->(@_);
  
          my $self = bless {}, $class;
  
          $self->{months} = ( $p{years} * 12 ) + $p{months};
  
          $self->{days} = ( $p{weeks} * 7 ) + $p{days};
  
          $self->{minutes} = ( $p{hours} * 60 ) + $p{minutes};
  
          $self->{seconds} = $p{seconds};
  
          if ( $p{nanoseconds} ) {
              $self->{nanoseconds} = $p{nanoseconds};
              $self->_normalize_nanoseconds;
          }
          else {
  
              # shortcut - if they don't need nanoseconds
              $self->{nanoseconds} = 0;
          }
  
          $self->{end_of_month} = (
                defined $p{end_of_month} ? $p{end_of_month}
              : $self->{months} < 0      ? 'preserve'
              :                            'wrap'
          );
  
          return $self;
      }
  }
  
  # make the signs of seconds, nanos the same; 0 < abs(nanos) < MAX_NANOS
  # NB this requires nanoseconds != 0 (callers check this already)
  sub _normalize_nanoseconds {
      my $self = shift;
  
      return
          if ( $self->{nanoseconds} == DateTime::INFINITY()
          || $self->{nanoseconds} == DateTime::NEG_INFINITY()
          || $self->{nanoseconds} eq DateTime::NAN() );
  
      my $seconds = $self->{seconds} + $self->{nanoseconds} / MAX_NANOSECONDS;
      $self->{seconds}     = int($seconds);
      $self->{nanoseconds} = $self->{nanoseconds} % MAX_NANOSECONDS;
      $self->{nanoseconds} -= MAX_NANOSECONDS if $seconds < 0;
  }
  
  sub clone { bless { %{ $_[0] } }, ref $_[0] }
  
  sub years       { abs( $_[0]->in_units('years') ) }
  sub months      { abs( $_[0]->in_units( 'months', 'years' ) ) }
  sub weeks       { abs( $_[0]->in_units('weeks') ) }
  sub days        { abs( $_[0]->in_units( 'days', 'weeks' ) ) }
  sub hours       { abs( $_[0]->in_units('hours') ) }
  sub minutes     { abs( $_[0]->in_units( 'minutes', 'hours' ) ) }
  sub seconds     { abs( $_[0]->in_units('seconds') ) }
  sub nanoseconds { abs( $_[0]->in_units( 'nanoseconds', 'seconds' ) ) }
  
  sub is_positive { $_[0]->_has_positive  && !$_[0]->_has_negative }
  sub is_negative { !$_[0]->_has_positive && $_[0]->_has_negative }
  
  sub _has_positive {
      ( grep { $_ > 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
  }
  
  sub _has_negative {
      ( grep { $_ < 0 } @{ $_[0] }{@all_units} ) ? 1 : 0;
  }
  
  sub is_zero {
      return 0 if grep { $_ != 0 } @{ $_[0] }{@all_units};
      return 1;
  }
  
  sub delta_months      { $_[0]->{months} }
  sub delta_days        { $_[0]->{days} }
  sub delta_minutes     { $_[0]->{minutes} }
  sub delta_seconds     { $_[0]->{seconds} }
  sub delta_nanoseconds { $_[0]->{nanoseconds} }
  
  sub deltas {
      map { $_ => $_[0]->{$_} } @all_units;
  }
  
  sub in_units {
      my $self  = shift;
      my @units = @_;
  
      my %units = map { $_ => 1 } @units;
  
      my %ret;
  
      my ( $months, $days, $minutes, $seconds )
          = @{$self}{qw( months days minutes seconds )};
  
      if ( $units{years} ) {
          $ret{years} = int( $months / 12 );
          $months -= $ret{years} * 12;
      }
  
      if ( $units{months} ) {
          $ret{months} = $months;
      }
  
      if ( $units{weeks} ) {
          $ret{weeks} = int( $days / 7 );
          $days -= $ret{weeks} * 7;
      }
  
      if ( $units{days} ) {
          $ret{days} = $days;
      }
  
      if ( $units{hours} ) {
          $ret{hours} = int( $minutes / 60 );
          $minutes -= $ret{hours} * 60;
      }
  
      if ( $units{minutes} ) {
          $ret{minutes} = $minutes;
      }
  
      if ( $units{seconds} ) {
          $ret{seconds} = $seconds;
          $seconds = 0;
      }
  
      if ( $units{nanoseconds} ) {
          $ret{nanoseconds} = $seconds * MAX_NANOSECONDS + $self->{nanoseconds};
      }
  
      wantarray ? @ret{@units} : $ret{ $units[0] };
  }
  
  sub is_wrap_mode     { $_[0]->{end_of_month} eq 'wrap'     ? 1 : 0 }
  sub is_limit_mode    { $_[0]->{end_of_month} eq 'limit'    ? 1 : 0 }
  sub is_preserve_mode { $_[0]->{end_of_month} eq 'preserve' ? 1 : 0 }
  
  sub end_of_month_mode { $_[0]->{end_of_month} }
  
  sub calendar_duration {
      my $self = shift;
  
      return ( ref $self )
          ->new( map { $_ => $self->{$_} } qw( months days end_of_month ) );
  }
  
  sub clock_duration {
      my $self = shift;
  
      return ( ref $self )
          ->new( map { $_ => $self->{$_} }
              qw( minutes seconds nanoseconds end_of_month ) );
  }
  
  sub inverse {
      my $self = shift;
      my %p    = @_;
  
      my %new;
      foreach my $u (@all_units) {
          $new{$u} = $self->{$u};
  
          # avoid -0 bug
          $new{$u} *= -1 if $new{$u};
      }
  
      $new{end_of_month} = $p{end_of_month}
          if exists $p{end_of_month};
  
      return ( ref $self )->new(%new);
  }
  
  sub add_duration {
      my ( $self, $dur ) = @_;
  
      foreach my $u (@all_units) {
          $self->{$u} += $dur->{$u};
      }
  
      $self->_normalize_nanoseconds if $self->{nanoseconds};
  
      return $self;
  }
  
  sub add {
      my $self = shift;
  
      return $self->add_duration( $self->_duration_object_from_args(@_) );
  }
  
  sub subtract {
      my $self = shift;
  
      return $self->subtract_duration( $self->_duration_object_from_args(@_) );
  }
  
  # Syntactic sugar for add and subtract: use a duration object if it's
  # supplied, otherwise build a new one from the arguments.
  sub _duration_object_from_args {
      my $self = shift;
  
      return $_[0]
          if @_ == 1 && blessed( $_[0] ) && $_[0]->isa(__PACKAGE__);
  
      return __PACKAGE__->new(@_);
  }
  
  sub subtract_duration { return $_[0]->add_duration( $_[1]->inverse ) }
  
  {
      my $check = validation_for(
          name             => '_check_multiply_params',
          name_is_optional => 1,
          params           => [
              { type => t('Int') },
          ],
      );
  
      sub multiply {
          my $self = shift;
          my ($multiplier) = $check->(@_);
  
          foreach my $u (@all_units) {
              $self->{$u} *= $multiplier;
          }
  
          $self->_normalize_nanoseconds if $self->{nanoseconds};
  
          return $self;
      }
  }
  
  sub compare {
      my ( undef, $dur1, $dur2, $dt ) = @_;
  
      $dt ||= DateTime->now;
  
      return DateTime->compare(
          $dt->clone->add_duration($dur1),
          $dt->clone->add_duration($dur2)
      );
  }
  
  sub _add_overload {
      my ( $d1, $d2, $rev ) = @_;
  
      ( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
  
      if ( DateTime::Helpers::isa( $d2, 'DateTime' ) ) {
          $d2->add_duration($d1);
          return;
      }
  
      # will also work if $d1 is a DateTime.pm object
      return $d1->clone->add_duration($d2);
  }
  
  sub _subtract_overload {
      my ( $d1, $d2, $rev ) = @_;
  
      ( $d1, $d2 ) = ( $d2, $d1 ) if $rev;
  
      Carp::croak(
          'Cannot subtract a DateTime object from a DateTime::Duration object')
          if DateTime::Helpers::isa( $d2, 'DateTime' );
  
      return $d1->clone->subtract_duration($d2);
  }
  
  sub _multiply_overload {
      my $self = shift;
  
      my $new = $self->clone;
  
      return $new->multiply(shift);
  }
  
  sub _compare_overload {
      Carp::croak( 'DateTime::Duration does not overload comparison.'
              . '  See the documentation on the compare() method for details.'
      );
  }
  
  1;
  
  # ABSTRACT: Duration objects for date math
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Duration - Duration objects for date math
  
  =head1 VERSION
  
  version 1.54
  
  =head1 SYNOPSIS
  
      use DateTime::Duration;
  
      $dur = DateTime::Duration->new(
          years        => 3,
          months       => 5,
          weeks        => 1,
          days         => 1,
          hours        => 6,
          minutes      => 15,
          seconds      => 45,
          nanoseconds  => 12000,
          end_of_month => 'limit',
      );
  
      my ( $days, $hours, $seconds )
          = $dur->in_units( 'days', 'hours', 'seconds' );
  
      # Human-readable accessors, always positive, but consider using
      # DateTime::Format::Duration instead
      $dur->years;
      $dur->months;
      $dur->weeks;
      $dur->days;
      $dur->hours;
      $dur->minutes;
      $dur->seconds;
      $dur->nanoseconds;
  
      $dur->is_wrap_mode;
      $dur->is_limit_mode;
      $dur->is_preserve_mode;
  
      print $dur->end_of_month_mode;
  
      # Multiply all values by -1
      my $opposite = $dur->inverse;
  
      my $bigger  = $dur1 + $dur2;
      my $smaller = $dur1 - $dur2;    # the result could be negative
      my $bigger  = $dur1 * 3;
  
      my $base_dt = DateTime->new( year => 2000 );
      my @sorted
          = sort { DateTime::Duration->compare( $a, $b, $base_dt ) } @durations;
  
      if ( $dur->is_positive ) {...}
      if ( $dur->is_zero )     {...}
      if ( $dur->is_negative ) {...}
  
  =head1 DESCRIPTION
  
  This is a simple class for representing duration objects. These objects are
  used whenever you do date math with L<DateTime>.
  
  See the L<How DateTime Math Works|DateTime/"How DateTime Math Works"> section
  of the L<DateTime> documentation for more details. The short course: One
  cannot in general convert between seconds, minutes, days, and months, so this
  class will never do so. Instead, create the duration with the desired units to
  begin with, for example by calling the appropriate subtraction/delta method on
  a L<DateTime> object.
  
  =head1 METHODS
  
  Like L<DateTime> itself, C<DateTime::Duration> returns the object from
  mutator methods in order to make method chaining possible.
  
  C<DateTime::Duration> has the following methods:
  
  =head2 DateTime::Duration->new( ... )
  
  This class method accepts the following parameters:
  
  =over 4
  
  =item * year
  
  An integer containing the number of years in the duration. This is optional.
  
  =item * month
  
  An integer containing the number of months in the duration. This is optional.
  
  =item * weeks
  
  An integer containing the number of weeks in the duration. This is optional.
  
  =item * days
  
  An integer containing the number of days in the duration. This is optional.
  
  =item * hours
  
  An integer containing the number of hours in the duration. This is optional.
  
  =item * minutes
  
  An integer containing the number of minutes in the duration. This is optional.
  
  =item * seconds
  
  An integer containing the number of seconds in the duration. This is optional.
  
  =item * nanoseconds
  
  An integer containing the number of nanoseconds in the duration. This is
  optional.
  
  =item * end_of_month
  
  This must be either C<"wrap">, C<"limit">, or C<"preserve">. This parameter
  specifies how date math that crosses the end of a month is handled.
  
  In C<"wrap"> mode, adding months or years that result in days beyond the end of
  the new month will roll over into the following month. For instance, adding
  one year to Feb 29 will result in Mar 1.
  
  If you specify C<"limit">, the end of the month is never crossed. Thus, adding
  one year to Feb 29, 2000 will result in Feb 28, 2001. If you were to then add
  three more years this will result in Feb 28, 2004.
  
  If you specify C<"preserve">, the same calculation is done as for C<"limit">
  except that if the original date is at the end of the month the new date will
  also be. For instance, adding one month to Feb 29, 2000 will result in Mar 31,
  2000.
  
  For positive durations, this parameter defaults to C<"wrap">. For negative
  durations, the default is C<"preserve">. This should match how most people
  "intuitively" expect datetime math to work.
  
  =back
  
  All of the duration units can be positive or negative. However, if any of the
  numbers are negative, the entire duration is negative.
  
  All of the numbers B<must be integers>.
  
  Internally, years as just treated as 12 months. Similarly, weeks are treated
  as 7 days, and hours are converted to minutes. Seconds and nanoseconds are
  both treated separately.
  
  =head2 $dur->clone
  
  Returns a new object with the same properties as the object on which
  this method was called.
  
  =head2 $dur->in_units( ... )
  
  Returns the length of the duration in the units (any of those that can be
  passed to C<< DateTime::Duration->new >>) given as arguments. All lengths are
  integral, but may be negative. Smaller units are computed from what remains
  after taking away the larger units given, so for example:
  
      my $dur = DateTime::Duration->new( years => 1, months => 15 );
  
      $dur->in_units('years');                # 2
      $dur->in_units('months');               # 27
      $dur->in_units( 'years', 'months' );    # (2, 3)
      $dur->in_units( 'weeks', 'days' );      # (0, 0) !
  
  The last example demonstrates that there will not be any conversion between
  units which don't have a fixed conversion rate. The only conversions possible
  are:
  
  =over 4
  
  =item * years <=> months
  
  =item * weeks <=> days
  
  =item * hours <=> minutes
  
  =item * seconds <=> nanoseconds
  
  =back
  
  For the explanation of why this is the case, please see the L<How DateTime
  Math Works|DateTime/"How DateTime Math Works"> section of the DateTime
  documentation
  
  Note that the numbers returned by this method may not match the values
  given to the constructor.
  
  In list context, C<< $dur->in_units >> returns the lengths in the order of the
  units given. In scalar context, it returns the length in the first unit (but
  still computes in terms of all given units).
  
  If you need more flexibility in presenting information about durations, please
  take a look a L<DateTime::Format::Duration>.
  
  =head2 $dur->is_positive, $dur->is_zero, $dur->is_negative
  
  Indicates whether or not the duration is positive, zero, or negative.
  
  If the duration contains both positive and negative units, then it
  will return false for B<all> of these methods.
  
  =head2 $dur->is_wrap_mode, $dur->is_limit_mode, $dur->is_preserve_mode
  
  Indicates what mode is used for end of month wrapping.
  
  =head2 $dur->end_of_month_mode
  
  Returns one of C<"wrap">, C<"limit">, or C<"preserve">.
  
  =head2 $dur->calendar_duration
  
  Returns a new object with the same I<calendar> delta (months and days
  only) and end of month mode as the current object.
  
  =head2 $dur->clock_duration
  
  Returns a new object with the same I<clock> deltas (minutes, seconds,
  and nanoseconds) and end of month mode as the current object.
  
  =head2 $dur->inverse( ... )
  
  Returns a new object with the same deltas as the current object, but
  multiplied by -1. The end of month mode for the new object will be the default
  end of month mode, which depends on whether the new duration is positive or
  negative.
  
  You can set the end of month mode in the inverted duration explicitly by
  passing an C<end_of_month> parameter to the C<< $dur->inverse >> method.
  
  =head2 $dur->add_duration($duration_object), $dur->subtract_duration($duration_object)
  
  Adds or subtracts one duration from another.
  
  =head2 $dur->add( ... ), $dur->subtract( ... )
  
  These accept either constructor parameters for a new C<DateTime::Duration>
  object or an already-constructed duration object.
  
  =head2 $dur->multiply($number)
  
  Multiplies each unit in the C<DateTime::Duration> object by the specified
  integer number.
  
  =head2 DateTime::Duration->compare( $duration1, $duration2, $base_datetime )
  
  This is a class method that can be used to compare or sort durations.
  Comparison is done by adding each duration to the specified
  L<DateTime> object and comparing the resulting datetimes. This is
  necessary because without a base, many durations are not comparable.
  For example, 1 month may or may not be longer than 29 days, depending
  on what datetime it is added to.
  
  If no base datetime is given, then the result of C<< DateTime->now >>
  is used instead. Using this default will give non-repeatable results
  if used to compare two duration objects containing different units.
  It will also give non-repeatable results if the durations contain
  multiple types of units, such as months and days.
  
  However, if you know that both objects only consist of one type of
  unit (months I<or> days I<or> hours, etc.), and each duration contains
  the same type of unit, then the results of the comparison will be
  repeatable.
  
  =head2 $dur->delta_months, $dur->delta_days, $dur->delta_minutes, $dur->delta_seconds, $dur->delta_nanoseconds
  
  These methods provide the information L<DateTime> needs for doing date
  math. The numbers returned may be positive or negative. This is mostly useful
  for doing date math in L<DateTime>.
  
  =head2 $dur->deltas
  
  Returns a hash with the keys "months", "days", "minutes", "seconds", and
  "nanoseconds", containing all the delta information for the object. This is
  mostly useful for doing date math in L<DateTime>.
  
  =head2 $dur->years, $dur->months, $dur->weeks, $dur->days, $dur->hours, $dur->minutes, $dur->seconds, $dur->nanoseconds
  
  These methods return numbers indicating how many of the given unit the
  object represents, after having done a conversion to any larger units.
  For example, days are first converted to weeks, and then the remainder
  is returned. These numbers are always positive.
  
  Here's what each method returns:
  
      $dur->years       == abs( $dur->in_units('years') )
      $dur->months      == abs( ( $dur->in_units( 'months', 'years' ) )[0] )
      $dur->weeks       == abs( $dur->in_units( 'weeks' ) )
      $dur->days        == abs( ( $dur->in_units( 'days', 'weeks' ) )[0] )
      $dur->hours       == abs( $dur->in_units( 'hours' ) )
      $dur->minutes     == abs( ( $dur->in_units( 'minutes', 'hours' ) )[0] )
      $dur->seconds     == abs( $dur->in_units( 'seconds' ) )
      $dur->nanoseconds == abs( ( $dur->in_units( 'nanoseconds', 'seconds' ) )[0] )
  
  If this seems confusing, remember that you can always use the C<<
  $dur->in_units >> method to specify exactly what you want.
  
  Better yet, if you are trying to generate output suitable for humans,
  use the C<DateTime::Format::Duration> module.
  
  =head2 Overloading
  
  This class overloads addition, subtraction, and mutiplication.
  
  Comparison is B<not> overloaded. If you attempt to compare durations
  using C<< <=> >> or C<cmp>, then an exception will be thrown!  Use the
  C<compare> class method instead.
  
  =head1 SEE ALSO
  
  datetime@perl.org mailing list
  
  http://datetime.perl.org/
  
  =head1 SUPPORT
  
  Support for this module is provided via the datetime@perl.org email
  list. See http://lists.perl.org/ for more details.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2020 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PERL5_DATETIME_DURATION

$fatpacked{"perl5/DateTime/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_HELPERS';
  package DateTime::Helpers;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.54';
  
  use Scalar::Util ();
  
  ## no critic (Subroutines::ProhibitBuiltinHomonyms)
  sub can {
      my $object = shift;
      my $method = shift;
  
      return unless Scalar::Util::blessed($object);
      return $object->can($method);
  }
  
  sub isa {
      my $object = shift;
      my $method = shift;
  
      return unless Scalar::Util::blessed($object);
      return $object->isa($method);
  }
  
  1;
PERL5_DATETIME_HELPERS

$fatpacked{"perl5/DateTime/Infinite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_INFINITE';
  ## no critic (Modules::ProhibitMultiplePackages)
  package DateTime::Infinite;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.54';
  
  use DateTime;
  use DateTime::TimeZone;
  
  use base qw(DateTime);
  
  foreach my $m (qw( set set_time_zone truncate )) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{"DateTime::Infinite::$m"} = sub { return $_[0] };
  }
  
  sub is_finite   {0}
  sub is_infinite {1}
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _rd2ymd {
      return $_[2] ? ( $_[1] ) x 7 : ( $_[1] ) x 3;
  }
  
  sub _seconds_as_components {
      return ( $_[1] ) x 3;
  }
  
  sub ymd {
      return $_[0]->iso8601;
  }
  
  sub mdy {
      return $_[0]->iso8601;
  }
  
  sub dmy {
      return $_[0]->iso8601;
  }
  
  sub hms {
      return $_[0]->iso8601;
  }
  
  sub hour_12 {
      return $_[0]->_infinity_string;
  }
  
  sub hour_12_0 {
      return $_[0]->_infinity_string;
  }
  
  sub datetime {
      return $_[0]->_infinity_string;
  }
  
  sub stringify {
      return $_[0]->_infinity_string;
  }
  
  sub _infinity_string {
      return $_[0]->{utc_rd_days} == DateTime::INFINITY
          ? DateTime::INFINITY . q{}
          : DateTime::NEG_INFINITY . q{};
  }
  
  sub _week_values { [ $_[0]->{utc_rd_days}, $_[0]->{utc_rd_days} ] }
  
  sub STORABLE_freeze {return}
  sub STORABLE_thaw   {return}
  
  package DateTime::Infinite::Future;
  
  use strict;
  use warnings;
  
  use base qw(DateTime::Infinite);
  
  {
      my $Pos = bless {
          utc_rd_days   => DateTime::INFINITY,
          utc_rd_secs   => DateTime::INFINITY,
          local_rd_days => DateTime::INFINITY,
          local_rd_secs => DateTime::INFINITY,
          rd_nanosecs   => DateTime::INFINITY,
          tz            => DateTime::TimeZone->new( name => 'floating' ),
          locale        => FakeLocale->instance,
          },
          __PACKAGE__;
  
      $Pos->_calc_utc_rd;
      $Pos->_calc_local_rd;
  
      sub new {$Pos}
  }
  
  package DateTime::Infinite::Past;
  
  use strict;
  use warnings;
  
  use base qw(DateTime::Infinite);
  
  {
      my $Neg = bless {
          utc_rd_days   => DateTime::NEG_INFINITY,
          utc_rd_secs   => DateTime::NEG_INFINITY,
          local_rd_days => DateTime::NEG_INFINITY,
          local_rd_secs => DateTime::NEG_INFINITY,
          rd_nanosecs   => DateTime::NEG_INFINITY,
          tz            => DateTime::TimeZone->new( name => 'floating' ),
          locale        => FakeLocale->instance,
          },
          __PACKAGE__;
  
      $Neg->_calc_utc_rd;
      $Neg->_calc_local_rd;
  
      sub new {$Neg}
  }
  
  package    # hide from PAUSE
      FakeLocale;
  
  use strict;
  use warnings;
  
  use DateTime::Locale;
  
  my $Instance;
  
  sub instance {
      return $Instance ||= bless { locale => DateTime::Locale->load('en_US') },
          __PACKAGE__;
  }
  
  sub id {
      return 'infinite';
  }
  
  sub language_id {
      return 'infinite';
  }
  
  sub name {
      'Fake locale for Infinite DateTime objects';
  }
  
  sub language {
      'Fake locale for Infinite DateTime objects';
  }
  
  my @methods = qw(
      script_id
      territory_id
      variant_id
      script
      territory
      variant
      native_name
      native_language
      native_script
      native_territory
      native_variant
  );
  
  for my $meth (@methods) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{$meth} = sub {undef};
  }
  
  # Totally arbitrary
  sub first_day_of_week {
      return 1;
  }
  
  sub prefers_24_hour_time {
      return 0;
  }
  
  our $AUTOLOAD;
  
  ## no critic (ClassHierarchies::ProhibitAutoloading)
  sub AUTOLOAD {
      my $self = shift;
  
      my ($meth) = $AUTOLOAD =~ /::(\w+)$/;
  
      if ( $meth =~ /format/ && $meth !~ /^(?:day|month|quarter)/ ) {
          return $self->{locale}->$meth(@_);
      }
  
      return [];
  }
  
  1;
  
  # ABSTRACT: Infinite past and future DateTime objects
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Infinite - Infinite past and future DateTime objects
  
  =head1 VERSION
  
  version 1.54
  
  =head1 SYNOPSIS
  
    my $future = DateTime::Infinite::Future->new;
    my $past   = DateTime::Infinite::Past->new;
  
  =head1 DESCRIPTION
  
  This module provides two L<DateTime> subclasses, C<DateTime::Infinite::Future>
  and C<DateTime::Infinite::Past>.
  
  The objects are always in the "floating" timezone, and this cannot be changed.
  
  =head1 METHODS
  
  The only constructor for these two classes is the C<new> method, as shown in
  the L</SYNOPSIS>. This method takes no parameters.
  
  All "get" methods in this module simply return infinity, positive or
  negative. If the method is expected to return a string, it returns the string
  representation of positive or negative infinity used by your system. For
  example, on my system calling C<< $dt->year >>> returns a number which when
  printed appears either "Inf" or "-Inf".
  
  This also applies to methods that are compound stringifications, which return
  the same strings even for things like C<< $dt->ymd >> or C<< $dt->iso8601 >>
  
  The object is not mutable, so the C<< $dt->set >>, C<< $dt->set_time_zone >>,
  and C<< $dt->truncate >> methods are all do-nothing methods that simply return
  the object they are called with.
  
  Obviously, the C<< $dt->is_finite >> method returns false and the C<<
  $dt->is_infinite >> method returns true.
  
  =head1 SEE ALSO
  
  datetime@perl.org mailing list
  
  http://datetime.perl.org/
  
  =head1 BUGS
  
  There seem to be lots of problems when dealing with infinite numbers on
  Win32. This may be a problem with this code, Perl, or Win32's IEEE math
  implementation. Either way, the module may not be well-behaved on Win32
  operating systems.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2020 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PERL5_DATETIME_INFINITE

$fatpacked{"perl5/DateTime/LeapSecond.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_LEAPSECOND';
  package DateTime::LeapSecond;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.54';
  
  our ( @RD, @LEAP_SECONDS, %RD_LENGTH );
  
  use DateTime;
  
  # Generates a Perl binary decision tree
  sub _make_utx {
      my ( $beg, $end, $tab, $op ) = @_;
      my $step = int( ( $end - $beg ) / 2 );
      my $tmp;
      if ( $step <= 0 ) {
          $tmp = "${tab}return $LEAP_SECONDS[$beg + 1];\n";
          return $tmp;
      }
      $tmp = "${tab}if (\$val < " . $RD[ $beg + $step ] . ") {\n";
      $tmp .= _make_utx( $beg, $beg + $step, $tab . q{    }, $op );
      $tmp .= "${tab}}\n";
      $tmp .= "${tab}else {\n";
      $tmp .= _make_utx( $beg + $step, $end, $tab . q{    }, $op );
      $tmp .= "${tab}}\n";
      return $tmp;
  }
  
  # Process BEGIN data and write binary tree decision table
  sub _init {
      my $value = -1;
      while (@_) {
          my ( $year, $mon, $mday, $leap_seconds )
              = ( shift, shift, shift, shift );
  
          # print "$year,$mon,$mday\n";
  
          ## no critic (Subroutines::ProtectPrivateSubs)
          my $utc_epoch
              = DateTime->_ymd2rd( $year, ( $mon =~ /Jan/i ? 1 : 7 ), $mday );
  
          $value++;
          push @LEAP_SECONDS, $value;
          push @RD,           $utc_epoch;
  
          $RD_LENGTH{ $utc_epoch - 1 } = $leap_seconds;
  
          # warn "$year,$mon,$mday = $utc_epoch +$value";
      }
  
      push @LEAP_SECONDS, ++$value;
  
      my $tmp;
  
      # write binary tree decision table
  
      $tmp = "sub leap_seconds {\n";
      $tmp .= "    my \$val = shift;\n";
      $tmp .= _make_utx( -1, 1 + $#RD, q{    }, '+' );
      $tmp .= "}; 1\n";
  
      # NOTE: uncomment the line below to see the code:
      #warn $tmp;
  
      ## no critic (BuiltinFunctions::ProhibitStringyEval)
      eval $tmp or die $@;
  }
  
  sub extra_seconds {
      exists $RD_LENGTH{ $_[0] } ? $RD_LENGTH{ $_[0] } : 0;
  }
  
  sub day_length {
      exists $RD_LENGTH{ $_[0] } ? 86400 + $RD_LENGTH{ $_[0] } : 86400;
  }
  
  sub _initialize {
  
      # There are no leap seconds before 1972, because that's the
      # year this system was implemented.
      #
      # year month day number-of-leapseconds
      #
      _init(
          qw(
              1972  Jul. 1  +1
              1973  Jan. 1  +1
              1974  Jan. 1  +1
              1975  Jan. 1  +1
              1976  Jan. 1  +1
              1977  Jan. 1  +1
              1978  Jan. 1  +1
              1979  Jan. 1  +1
              1980  Jan. 1  +1
              1981  Jul. 1  +1
              1982  Jul. 1  +1
              1983  Jul. 1  +1
              1985  Jul. 1  +1
              1988  Jan. 1  +1
              1990  Jan. 1  +1
              1991  Jan. 1  +1
              1992  Jul. 1  +1
              1993  Jul. 1  +1
              1994  Jul. 1  +1
              1996  Jan. 1  +1
              1997  Jul. 1  +1
              1999  Jan. 1  +1
              2006  Jan. 1  +1
              2009  Jan. 1  +1
              2012  Jul. 1  +1
              2015  Jul. 1  +1
              2017  Jan. 1  +1
              )
      );
  }
  
  __PACKAGE__->_initialize();
  
  1;
  
  # ABSTRACT: leap seconds table and utilities
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::LeapSecond - leap seconds table and utilities
  
  =head1 VERSION
  
  version 1.54
  
  =head1 SYNOPSIS
  
      use DateTime;
      use DateTime::LeapSecond;
  
      print "Leap seconds between years 1990 and 2000 are ";
      print DateTime::Leapsecond::leap_seconds($utc_rd_2000)
          - DateTime::Leapsecond::leap_seconds($utc_rd_1990);
  
  =head1 DESCRIPTION
  
  This module is used to calculate leap seconds for a given Rata Die day. It is
  used when L<DateTime> cannot compile the XS version of this code.
  
  This library is known to be accurate for dates until Jun 2020.
  
  There are no leap seconds before 1972, because that's the year this
  system was implemented.
  
  =over 4
  
  =item * leap_seconds($rd)
  
  Returns the number of accumulated leap seconds for a given day.
  
  =item * extra_seconds($rd)
  
  Returns the number of leap seconds for a given day,
  in the range -2 .. 2.
  
  =item * day_length($rd)
  
  Returns the number of seconds for a given day,
  in the range 86398 .. 86402.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://hpiers.obspm.fr/eop-pc/earthor/utc/leapsecond.html>
  
  http://datetime.perl.org
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2020 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PERL5_DATETIME_LEAPSECOND

$fatpacked{"perl5/DateTime/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_PP';
  package DateTime::PP;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.54';
  
  ## no critic (Variables::ProhibitPackageVars)
  $DateTime::IsPurePerl = 1;
  ## use critic
  
  my @MonthLengths = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
  
  my @LeapYearMonthLengths = @MonthLengths;
  $LeapYearMonthLengths[1]++;
  
  my @EndOfLastMonthDayOfYear;
  {
      my $x = 0;
      foreach my $length (@MonthLengths) {
          push @EndOfLastMonthDayOfYear, $x;
          $x += $length;
      }
  }
  
  my @EndOfLastMonthDayOfLeapYear = @EndOfLastMonthDayOfYear;
  $EndOfLastMonthDayOfLeapYear[$_]++ for 2 .. 11;
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _time_as_seconds {
      shift;
      my ( $hour, $min, $sec ) = @_;
  
      $hour ||= 0;
      $min  ||= 0;
      $sec  ||= 0;
  
      my $secs = $hour * 3600 + $min * 60 + $sec;
      return $secs;
  }
  
  sub _rd2ymd {
      my $class = shift;
  
      use integer;
      my $d  = shift;
      my $rd = $d;
  
      my $yadj = 0;
      my ( $c, $y, $m );
  
      # add 306 days to make relative to Mar 1, 0
      if ( ( $d += 306 ) <= 0 ) {
  
          # avoid ambiguity in C division of negatives
          $yadj = -( -$d / 146097 + 1 );
          $d -= $yadj * 146097;
      }
  
      $c = ( $d * 4 - 1 )
          / 146097;    # calc # of centuries $d is after 29 Feb of yr 0
      $d -= $c * 146097 / 4;         # (4 centuries = 146097 days)
      $y = ( $d * 4 - 1 ) / 1461;    # calc number of years into the century,
      $d -= $y * 1461 / 4;           # again March-based (4 yrs =~ 146[01] days)
      $m = ( $d * 12 + 1093 )
          / 367;    # get the month (3..14 represent March through
      $d -= ( $m * 367 - 1094 ) / 12;    # February of following year)
      $y += $c * 100 + $yadj * 400;      # get the real year, which is off by
                                         # one if month is January or February
  
      if ( $m > 12 ) {
          ++$y;
          $m -= 12;
      }
  
      if ( $_[0] ) {
          my $dow;
  
          if ( $rd < -6 ) {
              $dow = ( $rd + 6 ) % 7;
              $dow += $dow ? 8 : 1;
          }
          else {
              $dow = ( ( $rd + 6 ) % 7 ) + 1;
          }
  
          my $doy = $class->_end_of_last_month_day_of_year( $y, $m );
  
          $doy += $d;
  
          my $quarter;
          {
              no integer;
              $quarter = int( ( 1 / 3.1 ) * $m ) + 1;
          }
  
          my $qm = ( 3 * $quarter ) - 2;
  
          my $doq
              = ( $doy - $class->_end_of_last_month_day_of_year( $y, $qm ) );
  
          return ( $y, $m, $d, $dow, $doy, $quarter, $doq );
      }
  
      return ( $y, $m, $d );
  }
  
  sub _ymd2rd {
      shift;    # ignore class
  
      use integer;
      my ( $y, $m, $d ) = @_;
      my $adj;
  
      # make month in range 3..14 (treat Jan & Feb as months 13..14 of
      # prev year)
      if ( $m <= 2 ) {
          $y -= ( $adj = ( 14 - $m ) / 12 );
          $m += 12 * $adj;
      }
      elsif ( $m > 14 ) {
          $y += ( $adj = ( $m - 3 ) / 12 );
          $m -= 12 * $adj;
      }
  
      # make year positive (oh, for a use integer 'sane_div'!)
      if ( $y < 0 ) {
          $d -= 146097 * ( $adj = ( 399 - $y ) / 400 );
          $y += 400 * $adj;
      }
  
      # add: day of month, days of previous 0-11 month period that began
      # w/March, days of previous 0-399 year period that began w/March
      # of a 400-multiple year), days of any 400-year periods before
      # that, and finally subtract 306 days to adjust from Mar 1, year
      # 0-relative to Jan 1, year 1-relative (whew)
  
      $d
          += ( $m * 367 - 1094 ) / 12
          + $y % 100 * 1461 / 4
          + ( $y / 100 * 36524 + $y / 400 )
          - 306;
  }
  
  sub _seconds_as_components {
      shift;
      my $secs     = shift;
      my $utc_secs = shift;
      my $modifier = shift || 0;
  
      use integer;
  
      $secs -= $modifier;
  
      my $hour = $secs / 3600;
      $secs -= $hour * 3600;
  
      my $minute = $secs / 60;
  
      my $second = $secs - ( $minute * 60 );
  
      if ( $utc_secs && $utc_secs >= 86400 ) {
  
          # there is no such thing as +3 or more leap seconds!
          die "Invalid UTC RD seconds value: $utc_secs"
              if $utc_secs > 86401;
  
          $second += $utc_secs - 86400 + 60;
  
          $minute = 59;
  
          $hour--;
          $hour = 23 if $hour < 0;
      }
  
      return ( $hour, $minute, $second );
  }
  
  sub _end_of_last_month_day_of_year {
      my $class = shift;
  
      my ( $y, $m ) = @_;
      $m--;
      return (
            $class->_is_leap_year($y)
          ? $EndOfLastMonthDayOfLeapYear[$m]
          : $EndOfLastMonthDayOfYear[$m]
      );
  }
  
  sub _is_leap_year {
      shift;
      my $year = shift;
  
      # According to Bjorn Tackmann, this line prevents an infinite loop
      # when running the tests under Qemu. I cannot reproduce this on
      # Ubuntu or with Strawberry Perl on Win2K.
      return 0
          if $year == DateTime::INFINITY() || $year == DateTime::NEG_INFINITY();
      return 0 if $year % 4;
      return 1 if $year % 100;
      return 0 if $year % 400;
  
      return 1;
  }
  
  sub _day_length { DateTime::LeapSecond::day_length( $_[1] ) }
  
  sub _accumulated_leap_seconds { DateTime::LeapSecond::leap_seconds( $_[1] ) }
  
  my @subs = qw(
      _time_as_seconds
      _rd2ymd
      _ymd2rd
      _seconds_as_components
      _end_of_last_month_day_of_year
      _is_leap_year
      _day_length
      _accumulated_leap_seconds
  );
  
  for my $sub (@subs) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{ 'DateTime::' . $sub } = __PACKAGE__->can($sub);
  }
  
  # This is down here so that _ymd2rd is available when it loads,
  # because it will load DateTime::LeapSecond, which needs
  # DateTime->_ymd2rd to be available when it is loading
  require DateTime::PPExtra;
  
  1;
PERL5_DATETIME_PP

$fatpacked{"perl5/DateTime/PPExtra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_PPEXTRA';
  package DateTime::PPExtra;
  
  use strict;
  use warnings;
  
  our $VERSION = '1.54';
  
  use DateTime::LeapSecond;
  
  ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
  sub _normalize_tai_seconds {
      return
          if
          grep { $_ == DateTime::INFINITY() || $_ == DateTime::NEG_INFINITY() }
          @_[ 1, 2 ];
  
      # This must be after checking for infinity, because it breaks in
      # presence of use integer !
      use integer;
  
      my $adj;
  
      if ( $_[2] < 0 ) {
          $adj = ( $_[2] - 86399 ) / 86400;
      }
      else {
          $adj = $_[2] / 86400;
      }
  
      $_[1] += $adj;
  
      $_[2] -= $adj * 86400;
  }
  
  sub _normalize_leap_seconds {
  
      # args: 0 => days, 1 => seconds
      my $delta_days;
  
      use integer;
  
      # rough adjust - can adjust many days
      if ( $_[2] < 0 ) {
          $delta_days = ( $_[2] - 86399 ) / 86400;
      }
      else {
          $delta_days = $_[2] / 86400;
      }
  
      my $new_day = $_[1] + $delta_days;
      my $delta_seconds
          = ( 86400 * $delta_days )
          + DateTime::LeapSecond::leap_seconds($new_day)
          - DateTime::LeapSecond::leap_seconds( $_[1] );
  
      $_[2] -= $delta_seconds;
      $_[1] = $new_day;
  
      # fine adjust - up to 1 day
      my $day_length = DateTime::LeapSecond::day_length($new_day);
      if ( $_[2] >= $day_length ) {
          $_[2] -= $day_length;
          $_[1]++;
      }
      elsif ( $_[2] < 0 ) {
          $day_length = DateTime::LeapSecond::day_length( $new_day - 1 );
          $_[2] += $day_length;
          $_[1]--;
      }
  }
  
  my @subs = qw(
      _normalize_tai_seconds
      _normalize_leap_seconds
  );
  
  for my $sub (@subs) {
      ## no critic (TestingAndDebugging::ProhibitNoStrict)
      no strict 'refs';
      *{ 'DateTime::' . $sub } = __PACKAGE__->can($sub);
  }
  
  1;
PERL5_DATETIME_PPEXTRA

$fatpacked{"perl5/DateTime/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DATETIME_TYPES';
  package DateTime::Types;
  
  use strict;
  use warnings;
  use namespace::autoclean;
  
  our $VERSION = '1.54';
  
  use parent 'Specio::Exporter';
  
  use Specio 0.18;
  use Specio::Declare;
  use Specio::Library::Builtins -reexport;
  use Specio::Library::Numeric -reexport;
  use Specio::Library::String;
  
  any_can_type(
      'ConvertibleObject',
      methods => ['utc_rd_values'],
  );
  
  declare(
      'DayOfMonth',
      parent => t('Int'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 31";
      },
  );
  
  declare(
      'DayOfYear',
      parent => t('Int'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 366";
      },
  );
  
  object_isa_type(
      'Duration',
      class => 'DateTime::Duration',
  );
  
  enum(
      'EndOfMonthMode',
      values => [qw( wrap limit preserve )],
  );
  
  any_can_type(
      'Formatter',
      methods => ['format_datetime'],
  );
  
  my $locale_object = declare(
      'LocaleObject',
      parent => t('Object'),
      inline => sub {
  
          # Can't use $_[1] directly because 5.8 gives very weird errors
          my $var = $_[1];
          <<"EOF";
  (
      $var->isa('DateTime::Locale::FromData')
      || $var->isa('DateTime::Locale::Base')
  )
  EOF
      },
  );
  
  union(
      'Locale',
      of => [ t('NonEmptySimpleStr'), $locale_object ],
  );
  
  my $time_zone_object = object_can_type(
      'TZObject',
      methods => [
          qw(
              is_floating
              is_utc
              name
              offset_for_datetime
              short_name_for_datetime
              )
      ],
  );
  
  declare(
      'TimeZone',
      of => [ t('NonEmptySimpleStr'), $time_zone_object ],
  );
  
  declare(
      'Hour',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 23";
      },
  );
  
  declare(
      'Minute',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 59";
      },
  );
  
  declare(
      'Month',
      parent => t('PositiveInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 1 && $_[1] <= 12";
      },
  );
  
  declare(
      'Nanosecond',
      parent => t('PositiveOrZeroInt'),
  );
  
  declare(
      'Second',
      parent => t('PositiveOrZeroInt'),
      inline => sub {
          $_[0]->parent->inline_check( $_[1] )
              . " && $_[1] >= 0 && $_[1] <= 61";
      },
  );
  
  enum(
      'TruncationLevel',
      values => [
          qw(
              year
              quarter
              month
              day hour
              minute
              second
              nanosecond
              week
              local_week
              )
      ],
  );
  
  declare(
      'Year',
      parent => t('Int'),
  );
  
  1;
  
  # ABSTRACT: Types used for parameter checking in DateTime
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  DateTime::Types - Types used for parameter checking in DateTime
  
  =head1 VERSION
  
  version 1.54
  
  =head1 DESCRIPTION
  
  This module has no user-facing parts.
  
  =for Pod::Coverage .*
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/DateTime.pm/issues>.
  
  There is a mailing list available for users of this distribution,
  L<mailto:datetime@perl.org>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for DateTime can be found at L<https://github.com/houseabsolute/DateTime.pm>.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2003 - 2020 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
PERL5_DATETIME_TYPES

$fatpacked{"perl5/Digest/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_DIGEST_MD5';
  package Digest::MD5;
  
  use strict;
  use warnings;
  
  our $VERSION = '2.58';
  
  require Exporter;
  *import = \&Exporter::import;
  our @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  our @ISA;
  eval {
      require Digest::base;
      @ISA = qw/Digest::base/;
  };
  if ($@) {
      my $err = $@;
      *add_bits = sub { die $err };
  }
  
  
  eval {
      require XSLoader;
      XSLoader::load('Digest::MD5', $VERSION);
  };
  if ($@) {
      my $olderr = $@;
      eval {
  	# Try to load the pure perl version
  	require Digest::Perl::MD5;
  
  	Digest::Perl::MD5->import(qw(md5 md5_hex md5_base64));
  	unshift(@ISA, "Digest::Perl::MD5");  # make OO interface work
      };
      if ($@) {
  	# restore the original error
  	die $olderr;
      }
  }
  else {
      *reset = \&new;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::MD5 - Perl interface to the MD5 Algorithm
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5 qw(md5 md5_hex md5_base64);
  
   $digest = md5($data);
   $digest = md5_hex($data);
   $digest = md5_base64($data);
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile($file_handle);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  The C<Digest::MD5> module allows you to use the RSA Data Security
  Inc. MD5 Message Digest algorithm from within Perl programs.  The
  algorithm takes as input a message of arbitrary length and produces as
  output a 128-bit "fingerprint" or "message digest" of the input.
  
  Note that the MD5 algorithm is not as strong as it used to be.  It has
  since 2005 been easy to generate different messages that produce the
  same MD5 digest.  It still seems hard to generate messages that
  produce a given digest, but it is probably wise to move to stronger
  algorithms for applications that depend on the digest to uniquely identify
  a message.
  
  The C<Digest::MD5> module provide a procedural interface for simple
  use, as well as an object oriented interface that can handle messages
  of arbitrary length and which can read files directly.
  
  =head1 FUNCTIONS
  
  The following functions are provided by the C<Digest::MD5> module.
  None of these functions are exported by default.
  
  =over 4
  
  =item md5($data,...)
  
  This function will concatenate all arguments, calculate the MD5 digest
  of this "message", and return it in binary form.  The returned string
  will be 16 bytes long.
  
  The result of md5("a", "b", "c") will be exactly the same as the
  result of md5("abc").
  
  =item md5_hex($data,...)
  
  Same as md5(), but will return the digest in hexadecimal form. The
  length of the returned string will be 32 and it will only contain
  characters from this set: '0'..'9' and 'a'..'f'.
  
  =item md5_base64($data,...)
  
  Same as md5(), but will return the digest as a base64 encoded string.
  The length of the returned string will be 22 and it will only contain
  characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
  '/'.
  
  Note that the base64 encoded string returned is not padded to be a
  multiple of 4 bytes long.  If you want interoperability with other
  base64 encoded md5 digests you might want to append the redundant
  string "==" to the result.
  
  =back
  
  =head1 METHODS
  
  The object oriented interface to C<Digest::MD5> is described in this
  section.  After a C<Digest::MD5> object has been created, you will add
  data to it and finally ask for the digest in a suitable format.  A
  single object can be used to calculate multiple digests.
  
  The following methods are provided:
  
  =over 4
  
  =item $md5 = Digest::MD5->new
  
  The constructor returns a new C<Digest::MD5> object which encapsulate
  the state of the MD5 message-digest algorithm.
  
  If called as an instance method (i.e. $md5->new) it will just reset the
  state the object to the state of a newly created object.  No new
  object is created in this case.
  
  =item $md5->reset
  
  This is just an alias for $md5->new.
  
  =item $md5->clone
  
  This a copy of the $md5 object. It is useful when you do not want to
  destroy the digests state, but need an intermediate value of the
  digest, e.g. when calculating digests iteratively on a continuous data
  stream.  Example:
  
      my $md5 = Digest::MD5->new;
      while (<>) {
  	$md5->add($_);
  	print "Line $.: ", $md5->clone->hexdigest, "\n";
      }
  
  =item $md5->add($data,...)
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $md5 object itself.
  
  All these lines will have the same effect on the state of the $md5
  object:
  
      $md5->add("a"); $md5->add("b"); $md5->add("c");
      $md5->add("a")->add("b")->add("c");
      $md5->add("a", "b", "c");
      $md5->add("abc");
  
  =item $md5->addfile($io_handle)
  
  The $io_handle will be read until EOF and its content appended to the
  message we calculate the digest for.  The return value is the $md5
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $md5
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $md5 object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  C<binmode> before you pass it as argument to the addfile() method.
  
  =item $md5->add_bits($data, $nbits)
  
  =item $md5->add_bits($bitstring)
  
  Since the MD5 algorithm is byte oriented you might only add bits as
  multiples of 8, so you probably want to just use add() instead.  The
  add_bits() method is provided for compatibility with other digest
  implementations.  See L<Digest> for description of the arguments
  that add_bits() take.
  
  =item $md5->digest
  
  Return the binary digest for the message.  The returned string will be
  16 bytes long.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the C<Digest::MD5>
  object is automatically C<reset> and can be used to calculate another
  digest value.  Call $md5->clone->digest if you want to calculate the
  digest without resetting the digest state.
  
  =item $md5->hexdigest
  
  Same as $md5->digest, but will return the digest in hexadecimal
  form. The length of the returned string will be 32 and it will only
  contain characters from this set: '0'..'9' and 'a'..'f'.
  
  =item $md5->b64digest
  
  Same as $md5->digest, but will return the digest as a base64 encoded
  string.  The length of the returned string will be 22 and it will only
  contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
  and '/'.
  
  
  The base64 encoded string returned is not padded to be a multiple of 4
  bytes long.  If you want interoperability with other base64 encoded
  md5 digests you might want to append the string "==" to the result.
  
  =item @ctx = $md5->context
  
  =item $md5->context(@ctx)
  
  Saves or restores the internal state.
  When called with no arguments, returns a list:
  number of blocks processed,
  a 16-byte internal state buffer,
  then optionally up to 63 bytes of unprocessed data if there are any.
  When passed those same arguments, restores the state.
  This is only useful for specialised operations.
  
  =back
  
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::MD5 qw(md5_hex);
      print "Digest is ", md5_hex("foobarbaz"), "\n";
  
  The above example would print out the message:
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  The same checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  With OO style, you can break the message arbitrarily.  This means that we
  are no longer limited to have space for the whole message in memory, i.e.
  we can handle messages of any size.
  
  This is useful when calculating checksum for files:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode($fh);
  
      $md5 = Digest::MD5->new;
      while (<$fh>) {
          $md5->add($_);
      }
      close($fh);
      print $md5->b64digest, " $filename\n";
  
  Or we can use the addfile method for more efficient reading of
  the file:
  
      use Digest::MD5;
  
      my $filename = shift || "/etc/passwd";
      open (my $fh, '<', $filename) or die "Can't open '$filename': $!";
      binmode ($fh);
  
      print Digest::MD5->new->addfile($fh)->hexdigest, " $filename\n";
  
  Since the MD5 algorithm is only defined for strings of bytes, it can not be
  used on strings that contains chars with ordinal number above 255 (Unicode
  strings).  The MD5 functions and methods will croak if you try to feed them
  such input data:
  
      use Digest::MD5 qw(md5_hex);
  
      my $str = "abc\x{300}";
      print md5_hex($str), "\n";  # croaks
      # Wide character in subroutine entry
  
  What you can do is calculate the MD5 checksum of the UTF-8
  representation of such strings.  This is achieved by filtering the
  string through encode_utf8() function:
  
      use Digest::MD5 qw(md5_hex);
      use Encode qw(encode_utf8);
  
      my $str = "abc\x{300}";
      print md5_hex(encode_utf8($str)), "\n";
      # 8c2d46911f3f5a326455f0ed7a8ed3b3
  
  =head1 SEE ALSO
  
  L<Digest>,
  L<Digest::MD2>,
  L<Digest::SHA>,
  L<Digest::HMAC>
  
  L<md5sum(1)>
  
  RFC 1321
  
  http://en.wikipedia.org/wiki/MD5
  
  The paper "How to Break MD5 and Other Hash Functions" by Xiaoyun Wang
  and Hongbo Yu.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 1998-2003 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. This implementation is
  derived from the reference C code in RFC 1321 which is covered by
  the following copyright statement:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original C<MD5> interface was written by Neil Winton
  (C<N.Winton@axion.bt.co.uk>).
  
  The C<Digest::MD5> module is written by Gisle Aas <gisle@ActiveState.com>.
  
  =cut
PERL5_DIGEST_MD5

$fatpacked{"perl5/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce reductions sum sum0
    sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.60";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  # Used by shuffle()
  our $RAND;
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first reductions
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqint uniqnum uniqstr zip mesh
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all apply a given block of code to a list of
  values.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The other scalar-returning list reduction functions are all specialisations of
  this generic idea.
  
  =head2 reductions
  
      @results = reductions { BLOCK } @list
  
  I<Since version 1.54.>
  
  Similar to C<reduce> except that it also returns the intermediate values along
  with the final result. As before, C<$a> is set to the first element of the
  given list, and the C<BLOCK> is then called once for remaining item in the
  list set into C<$b>, with the result being captured for return as well as
  becoming the new value for C<$a>.
  
  The returned list will begin with the initial value for C<$a>, followed by
  each return value from the block in order. The final value of the result will
  be identical to what the C<reduce> function would have returned given the same
  block and list.
  
      reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
      reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  This function is affected by the C<$RAND> variable.
  
  =cut
  
  =head2 sample
  
      my @items = sample $count, @values
  
  I<Since version 1.54.>
  
  Randomly select the given number of elements from the input list. Any given
  position in the input list will be selected at most once.
  
  If there are fewer than C<$count> items in the list then the function will
  return once all of them have been randomly selected; effectively the function
  behaves similarly to L</shuffle>.
  
  This function is affected by the C<$RAND> variable.
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqint
  
      my @subset = uniqint @values
  
  I<Since version 1.55.>
  
  Filters a list of values to remove subsequent duplicates, as judged by an
  integer numerical equality test. Preserves the order of unique elements, and
  retains the first value of any duplicate set. Values in the returned list will
  be coerced into integers.
  
      my $count = uniqint @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqint> are well-behaved as integers.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head2 zip
  
      my @result = zip [1..3], ['a'..'c'];
      # [1, 'a'], [2, 'b'], [3, 'c']
  
  I<Since version 1.56.>
  
  Returns a list of array references, composed of elements from the given list
  of array references. Each array in the returned list is composed of elements
  at that corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  The C<zip> function is particularly handy for iterating over multiple arrays
  at the same time with a C<foreach> loop, taking one element from each:
  
      foreach ( zip \@xs, \@ys, \@zs ) {
          my ($x, $y, $z) = @$_;
          ...
      }
  
  B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
  as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
  C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
  so make sure to invoke it with references to arrays.
  
  For a function similar to the C<zip> function from C<List::MoreUtils>, see
  L<mesh>.
  
      my @result = zip_shortest ...
  
  A variation of the function that differs in how it behaves when given input
  arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
  the input arrays run out of elements, discarding any remaining unused values
  from the others.
  
      my @result = zip_longest ...
  
  C<zip_longest> is an alias to the C<zip> function, provided simply to be
  explicit about that behaviour as compared to C<zip_shortest>.
  
  =head2 mesh
  
      my @result = mesh [1..3], ['a'..'c'];
      # (1, 'a', 2, 'b', 3, 'c')
  
  I<Since version 1.56.>
  
  Returns a list of items collected from elements of the given list of array
  references. Each section of items in the returned list is composed of elements
  at the corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  This is similar to L<zip>, except that all of the ranges in the result are
  returned in one long flattened list, instead of being bundled into separate
  arrays.
  
  Because it returns a flat list of items, the C<mesh> function is particularly
  useful for building a hash out of two separate arrays of keys and values:
  
      my %hash = mesh \@keys, \@values;
  
      my $href = { mesh \@keys, \@values };
  
  B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
  equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
  aliases of each other). This function does not apply a prototype, so make sure
  to invoke it with references to arrays.
  
      my @result = mesh_shortest ...
  
      my @result = mesh_longest ...
  
  These variations are similar to those of L<zip>, in that they differ in
  behaviour when one of the input lists runs out of elements before the others.
  
  =head1 CONFIGURATION VARIABLES
  
  =head2 $RAND
  
      local $List::Util::RAND = sub { ... };
  
  I<Since version 1.54.>
  
  This package variable is used by code which needs to generate random numbers
  (such as the L</shuffle> and L</sample> functions). If set to a CODE reference
  it provides an alternative to perl's builtin C<rand()> function. When a new
  random number is needed this function will be invoked with no arguments and is
  expected to return a floating-point value, of which only the fractional part
  will be used.
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
PERL5_LIST_UTIL

$fatpacked{"perl5/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.60";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
PERL5_LIST_UTIL_XS

$fatpacked{"perl5/Package/Stash/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_PACKAGE_STASH_XS';
  package Package::Stash::XS; # git description: 4627d81
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: faster and more correct implementation of the Package::Stash API
  
  our $VERSION = '0.29';
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      # we need to be careful not to touch $VERSION at compile time, otherwise
      # DynaLoader will assume it's set and check against it, which will cause
      # fail when being run in the checkout without dzil having set the actual
      # $VERSION
      exists $Package::Stash::XS::{VERSION}
          ? ${ $Package::Stash::XS::{VERSION} } : (),
  );
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Package::Stash::XS - faster and more correct implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.29
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash>, which provides the functionality in a
  way that's less buggy and much faster. It will be used by default if it's
  installed, and should be preferred in all environments with a compiler.
  
  =head1 SEE ALSO
  
  L<Package::Stash>
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash::XS
  
  You can also look for information at:
  
  =over 4
  
  =item * MetaCPAN
  
  L<https://metacpan.org/release/Package-Stash-XS>
  
  =item * Github
  
  L<https://github.com/moose/Package-Stash-XS>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash-XS>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash-XS>
  
  =back
  
  =for Pod::Coverage add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  remove_symbol
  
  =head1 BUGS
  
  No known bugs (but see the BUGS section in L<Package::Stash>).
  
  Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Package-Stash-XS>
  (or L<bug-Package-Stash-XS@rt.cpan.org|mailto:bug-Package-Stash-XS@rt.cpan.org>).
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Florian Ragwitz Karen Etheridge Dave Rolsky Justin Hunter Tim Bunce
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =item *
  
  Justin Hunter <justin.d.hunter@gmail.com>
  
  =item *
  
  Tim Bunce <Tim.Bunce@pobox.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PERL5_PACKAGE_STASH_XS

$fatpacked{"perl5/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.60";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  # populating @EXPORT_FAIL is done in the XS code
  sub export_fail {
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in this version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  Note that for internal reasons, all precompiled regexps (C<qr/.../>) are
  blessed references; thus C<ref()> returns the package name string C<"Regexp">
  on these but C<reftype()> will return the underlying C structure type of
  C<"REGEXP"> in all capitals.
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  standard operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  The C<$!> variable is commonly dual-valued, though it is also magical in other
  ways:
  
      $! = 1;
      $dual = isdual($!);                 # true
      print("$!\n");                      # "Operation not permitted"
  
  B<CAUTION>: This function is not as useful as it may seem. Dualvars are not a
  distinct concept in Perl, but a standard internal construct of all scalar
  values. Almost any value could be considered as a dualvar by this function
  through the course of normal operations.
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Vstrings are not implemented in this version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PERL5_SCALAR_UTIL

$fatpacked{"perl5/Sub/Identify.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SUB_IDENTIFY';
  package Sub::Identify;
  
  use strict;
  use Exporter;
  
  BEGIN {
      our $VERSION = '0.14';
      our @ISA = ('Exporter');
      our %EXPORT_TAGS = (
          all => [
              our @EXPORT_OK = qw(
                  sub_name
                  stash_name
                  sub_fullname
                  get_code_info
                  get_code_location
                  is_sub_constant
              )
          ]
      );
  
      our $IsPurePerl = 1;
      unless ($ENV{PERL_SUB_IDENTIFY_PP}) {
          if (
              eval {
                  require XSLoader;
                  XSLoader::load(__PACKAGE__, $VERSION);
                  1;
              }
          ) {
              $IsPurePerl = 0;
          }
          else {
              die $@ if $@ && $@ !~ /object version|loadable object/;
          }
      }
  
      if ($IsPurePerl) {
          require B;
          *get_code_info = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return;
              # bail out if GV is undefined
              $cv->GV->isa('B::SPECIAL') and return;
  
              return ($cv->GV->STASH->NAME, $cv->GV->NAME);
          };
          *get_code_location = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') && $cv->START->isa('B::COP')
                  or return;
  
              return ($cv->START->file, $cv->START->line);
          };
      }
      if ($IsPurePerl || $] < 5.016) {
          require B;
          *is_sub_constant = sub ($) {
              my ($coderef) = @_;
              ref $coderef or return 0;
              my $cv = B::svref_2object($coderef);
              $cv->isa('B::CV') or return 0;
              my $p = prototype $coderef;
              defined $p && $p eq "" or return 0;
              return ($cv->CvFLAGS & B::CVf_CONST()) == B::CVf_CONST();
          };
      }
  }
  
  sub stash_name   ($) { (get_code_info($_[0]))[0] }
  sub sub_name     ($) { (get_code_info($_[0]))[1] }
  sub sub_fullname ($) { join '::', get_code_info($_[0]) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Sub::Identify - Retrieve names of code references
  
  =head1 SYNOPSIS
  
      use Sub::Identify ':all';
      my $subname = sub_name( $some_coderef );
      my $packagename = stash_name( $some_coderef );
      # or, to get all at once...
      my $fully_qualified_name = sub_fullname( $some_coderef );
      defined $subname
          and say "this coderef points to sub $subname in package $packagename";
      my ($file, $line) = get_code_location( $some_coderef );
      $file
          and say "this coderef is defined at line $line in file $file";
      is_sub_constant( $some_coderef )
          and say "this coderef points to a constant subroutine";
  
  =head1 DESCRIPTION
  
  C<Sub::Identify> allows you to retrieve the real name of code references.
  
  It provides six functions, all of them taking a code reference.
  
  C<sub_name> returns the name of the code reference passed as an
  argument (or C<__ANON__> if it's an anonymous code reference),
  C<stash_name> returns its package, and C<sub_fullname> returns the
  concatenation of the two.
  
  C<get_code_info> returns a list of two elements, the package and the
  subroutine name (in case of you want both and are worried by the speed.)
  
  In case of subroutine aliasing, those functions always return the
  original name.
  
  C<get_code_location> returns a two-element list containing the file
  name and the line number where the subroutine has been defined.
  
  C<is_sub_constant> returns a boolean value indicating whether the
  subroutine is a constant or not.
  
  =head2 Pure-Perl version
  
  By default C<Sub::Identify> tries to load an XS implementation of the
  C<get_code_info>, C<get_code_location> and (on perl versions 5.16.0 and later)
  C<is_sub_constant> functions, for speed; if that fails, or if the environment
  variable C<PERL_SUB_IDENTIFY_PP> is defined to a true value, it will fall
  back to a pure perl implementation, that uses perl's introspection mechanism,
  provided by the C<B> module.
  
  =head1 SEE ALSO
  
  L<Sub::Util>, part of the module distribution L<Scalar::List::Utils>
  since version 1.40. Since this will be a core module starting with perl
  5.22.0, it is encouraged to migrate to Sub::Util when possible.
  
  L<Sub::Name>
  
  =head1 SOURCE
  
  A git repository for the sources is at L<https://github.com/rgs/Sub-Identify>.
  
  =head1 LICENSE
  
  (c) Rafael Garcia-Suarez (rgs at consttype dot org) 2005, 2008, 2012, 2014, 2015
  
  This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
PERL5_SUB_IDENTIFY

$fatpacked{"perl5/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.60";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
PERL5_SUB_UTIL

$fatpacked{"perl5/Variable/Magic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_VARIABLE_MAGIC';
  package Variable::Magic;
  
  use 5.008;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  Variable::Magic - Associate user-defined magic to variables from Perl.
  
  =head1 VERSION
  
  Version 0.62
  
  =cut
  
  our $VERSION;
  BEGIN {
   $VERSION = '0.62';
  }
  
  =head1 SYNOPSIS
  
      use Variable::Magic qw<wizard cast VMG_OP_INFO_NAME>;
  
      { # A variable tracer
       my $wiz = wizard(
        set  => sub { print "now set to ${$_[0]}!\n" },
        free => sub { print "destroyed!\n" },
       );
  
       my $a = 1;
       cast $a, $wiz;
       $a = 2;        # "now set to 2!"
      }               # "destroyed!"
  
      { # A hash with a default value
       my $wiz = wizard(
        data     => sub { $_[1] },
        fetch    => sub { $_[2] = $_[1] unless exists $_[0]->{$_[2]}; () },
        store    => sub { print "key $_[2] stored in $_[-1]\n" },
        copy_key => 1,
        op_info  => VMG_OP_INFO_NAME,
       );
  
       my %h = (_default => 0, apple => 2);
       cast %h, $wiz, '_default';
       print $h{banana}, "\n"; # "0" (there is no 'banana' key in %h)
       $h{pear} = 1;           # "key pear stored in helem"
      }
  
  =head1 DESCRIPTION
  
  Magic is Perl's way of enhancing variables.
  This mechanism lets the user add extra data to any variable and hook syntactical operations (such as access, assignment or destruction) that can be applied to it.
  With this module, you can add your own magic to any variable without having to write a single line of XS.
  
  You'll realize that these magic variables look a lot like tied variables.
  It is not surprising, as tied variables are implemented as a special kind of magic, just like any 'irregular' Perl variable : scalars like C<$!>, C<$(> or C<$^W>, the C<%ENV> and C<%SIG> hashes, the C<@ISA> array,  C<vec()> and C<substr()> lvalues, L<threads::shared> variables...
  They all share the same underlying C API, and this module gives you direct access to it.
  
  Still, the magic made available by this module differs from tieing and overloading in several ways :
  
  =over 4
  
  =item *
  
  Magic is not copied on assignment.
  
  You attach it to variables, not values (as for blessed references).
  
  =item *
  
  Magic does not replace the original semantics.
  
  Magic callbacks usually get triggered before the original action takes place, and cannot prevent it from happening.
  This also makes catching individual events easier than with C<tie>, where you have to provide fallbacks methods for all actions by usually inheriting from the correct C<Tie::Std*> class and overriding individual methods in your own class.
  
  =item *
  
  Magic is multivalued.
  
  You can safely apply different kinds of magics to the same variable, and each of them will be invoked successively.
  
  =item *
  
  Magic is type-agnostic.
  
  The same magic can be applied on scalars, arrays, hashes, subs or globs.
  But the same hook (see below for a list) may trigger differently depending on the type of the variable.
  
  =item *
  
  Magic is invisible at Perl level.
  
  Magical and non-magical variables cannot be distinguished with C<ref>, C<tied> or another trick.
  
  =item *
  
  Magic is notably faster.
  
  Mainly because perl's way of handling magic is lighter by nature, and because there is no need for any method resolution.
  Also, since you don't have to reimplement all the variable semantics, you only pay for what you actually use.
  
  =back
  
  The operations that can be overloaded are :
  
  =over 4
  
  =item *
  
  I<get>
  
  This magic is invoked when the variable is evaluated.
  It is never called for arrays and hashes.
  
  =item *
  
  I<set>
  
  This magic is called each time the value of the variable changes.
  It is called for array subscripts and slices, but never for hashes.
  
  =item *
  
  I<len>
  
  This magic only applies to arrays (though it used to also apply to scalars), and is triggered when the 'size' or the 'length' of the variable has to be known by Perl.
  This is typically the magic involved when an array is evaluated in scalar context, but also on array assignment and loops (C<for>, C<map> or C<grep>).
  The length is returned from the callback as an integer.
  
  Starting from perl 5.12, this magic is no longer called by the C<length> keyword, and starting from perl 5.17.4 it is also no longer called for scalars in any situation, making this magic only meaningful on arrays.
  You can use the constants L</VMG_COMPAT_SCALAR_LENGTH_NOLEN> and L</VMG_COMPAT_SCALAR_NOLEN> to see if this magic is available for scalars or not.
  
  =item *
  
  I<clear>
  
  This magic is invoked when the variable is reset, such as when an array is emptied.
  Please note that this is different from undefining the variable, even though the magic is called when the clearing is a result of the undefine (e.g. for an array, but actually a bug prevent it to work before perl 5.9.5 - see the L<history|/PERL MAGIC HISTORY>).
  
  =item *
  
  I<free>
  
  This magic is called when a variable is destroyed as the result of going out of scope (but not when it is undefined).
  It behaves roughly like Perl object destructors (i.e. C<DESTROY> methods), except that exceptions thrown from inside a I<free> callback will always be propagated to the surrounding code.
  
  =item *
  
  I<copy>
  
  When applied to tied arrays and hashes, this magic fires when you try to access or change their elements.
  
  Starting from perl 5.17.0, it can also be applied to closure prototypes, in which case the magic will be called when the prototype is cloned.
  The L</VMG_COMPAT_CODE_COPY_CLONE> constant is true when your perl support this feature.
  
  =item *
  
  I<dup>
  
  This magic is invoked when the variable is cloned across threads.
  It is currently not available.
  
  =item *
  
  I<local>
  
  When this magic is set on a variable, all subsequent localizations of the variable will trigger the callback.
  It is available on your perl if and only if C<MGf_LOCAL> is true.
  
  =back
  
  The following actions only apply to hashes and are available if and only if L</VMG_UVAR> is true.
  They are referred to as I<uvar> magics.
  
  =over 4
  
  =item *
  
  I<fetch>
  
  This magic is invoked each time an element is fetched from the hash.
  
  =item *
  
  I<store>
  
  This one is called when an element is stored into the hash.
  
  =item *
  
  I<exists>
  
  This magic fires when a key is tested for existence in the hash.
  
  =item *
  
  I<delete>
  
  This magic is triggered when a key is deleted in the hash, regardless of whether the key actually exists in it.
  
  =back
  
  You can refer to the tests to have more insight of where the different magics are invoked.
  
  =head1 FUNCTIONS
  
  =cut
  
  BEGIN {
   require XSLoader;
   XSLoader::load(__PACKAGE__, $VERSION);
  }
  
  =head2 C<wizard>
  
      wizard(
       data     => sub { ... },
       get      => sub { my ($ref, $data [, $op]) = @_; ... },
       set      => sub { my ($ref, $data [, $op]) = @_; ... },
       len      => sub {
        my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
       },
       clear    => sub { my ($ref, $data [, $op]) = @_; ... },
       free     => sub { my ($ref, $data [, $op]) = @_, ... },
       copy     => sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
       local    => sub { my ($ref, $data [, $op]) = @_; ... },
       fetch    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       store    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       exists   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       delete   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       copy_key => $bool,
       op_info  => [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
      )
  
  This function creates a 'wizard', an opaque object that holds the magic information.
  It takes a list of keys / values as argument, whose keys can be :
  
  =over 4
  
  =item *
  
  C<data>
  
  A code (or string) reference to a private data constructor.
  It is called in scalar context each time the magic is cast onto a variable, with C<$_[0]> being a reference to this variable and C<@_[1 .. @_-1]> being all extra arguments that were passed to L</cast>.
  The scalar returned from this call is then attached to the variable and can be retrieved later with L</getdata>.
  
  =item *
  
  C<get>, C<set>, C<len>, C<clear>, C<free>, C<copy>, C<local>, C<fetch>, C<store>, C<exists> and C<delete>
  
  Code (or string) references to the respective magic callbacks.
  You don't have to specify all of them : the magic corresponding to undefined entries will simply not be hooked.
  
  When those callbacks are executed, C<$_[0]> is a reference to the magic variable and C<$_[1]> is the associated private data (or C<undef> when no private data constructor is supplied with the wizard).
  Other arguments depend on which kind of magic is involved :
  
  =over 8
  
  =item *
  
  I<len>
  
  C<$_[2]> contains the natural, non-magical length of the variable (which can only be a scalar or an array as I<len> magic is only relevant for these types).
  The callback is expected to return the new scalar or array length to use, or C<undef> to default to the normal length.
  
  =item *
  
  I<copy>
  
  When the variable for which the magic is invoked is an array or an hash, C<$_[2]> is a either an alias or a copy of the current key, and C<$_[3]> is an alias to the current element (i.e. the value).
  Since C<$_[2]> might be a copy, it is useless to try to change it or cast magic on it.
  
  Starting from perl 5.17.0, this magic can also be called for code references.
  In this case, C<$_[2]> is always C<undef> and C<$_[3]> is a reference to the cloned anonymous subroutine.
  
  =item *
  
  I<fetch>, I<store>, I<exists> and I<delete>
  
  C<$_[2]> is an alias to the current key.
  Note that C<$_[2]> may rightfully be readonly if the key comes from a bareword, and as such it is unsafe to assign to it.
  You can ask for a copy instead by passing C<< copy_key => 1 >> to L</wizard> which, at the price of a small performance hit, allows you to safely assign to C<$_[2]> in order to e.g. redirect the action to another key.
  
  =back
  
  Finally, if C<< op_info => $num >> is also passed to C<wizard>, then one extra element is appended to C<@_>.
  Its nature depends on the value of C<$num> :
  
  =over 8
  
  =item *
  
  C<VMG_OP_INFO_NAME>
  
  C<$_[-1]> is the current op name.
  
  =item *
  
  C<VMG_OP_INFO_OBJECT>
  
  C<$_[-1]> is the C<B::OP> object for the current op.
  
  =back
  
  Both result in a small performance hit, but just getting the name is lighter than getting the op object.
  
  These callbacks are always executed in scalar context.
  The returned value is coerced into a signed integer, which is then passed straight to the perl magic API.
  However, note that perl currently only cares about the return value of the I<len> magic callback and ignores all the others.
  Starting with Variable::Magic 0.58, a reference returned from a non-I<len> magic callback will not be destroyed immediately but will be allowed to survive until the end of the statement that triggered the magic.
  This lets you use this return value as a token for triggering a destructor after the original magic action takes place.
  You can see an example of this technique in the L<cookbook|/COOKBOOK>.
  
  =back
  
  Each callback can be specified as :
  
  =over 4
  
  =item *
  
  a code reference, which will be called as a subroutine.
  
  =item *
  
  a string reference, where the string denotes which subroutine is to be called when magic is triggered.
  If the subroutine name is not fully qualified, then the current package at the time the magic is invoked will be used instead.
  
  =item *
  
  a reference to C<undef>, in which case a no-op magic callback is installed instead of the default one.
  This may especially be helpful for I<local> magic, where an empty callback prevents magic from being copied during localization.
  
  =back
  
  Note that I<free> magic is never called during global destruction, as there is no way to ensure that the wizard object and the callback were not destroyed before the variable.
  
  Here is a simple usage example :
  
      # A simple scalar tracer
      my $wiz = wizard(
       get  => sub { print STDERR "got ${$_[0]}\n" },
       set  => sub { print STDERR "set to ${$_[0]}\n" },
       free => sub { print STDERR "${$_[0]} was deleted\n" },
      );
  
  =cut
  
  sub wizard {
   if (@_ % 2) {
    require Carp;
    Carp::croak('Wrong number of arguments for wizard()');
   }
  
   my %opts = @_;
  
   my @keys = qw<op_info data get set len clear free copy dup>;
   push @keys, 'local' if MGf_LOCAL;
   push @keys, qw<fetch store exists delete copy_key> if VMG_UVAR;
  
   my ($wiz, $err);
   {
    local $@;
    $wiz = eval { _wizard(map $opts{$_}, @keys) };
    $err = $@;
   }
   if ($err) {
    $err =~ s/\sat\s+.*?\n//;
    require Carp;
    Carp::croak($err);
   }
  
   return $wiz;
  }
  
  =head2 C<cast>
  
      cast [$@%&*]var, $wiz, @args
  
  This function associates C<$wiz> magic to the supplied variable, without overwriting any other kind of magic.
  It returns true on success or when C<$wiz> magic is already attached, and croaks on error.
  When C<$wiz> provides a data constructor, it is called just before magic is cast onto the variable, and it receives a reference to the target variable in C<$_[0]> and the content of C<@args> in C<@_[1 .. @args]>.
  Otherwise, C<@args> is ignored.
  
      # Casts $wiz onto $x, passing (\$x, '1') to the data constructor.
      my $x;
      cast $x, $wiz, 1;
  
  The C<var> argument can be an array or hash value.
  Magic for these scalars behaves like for any other, except that it is dispelled when the entry is deleted from the container.
  For example, if you want to call C<POSIX::tzset> each time the C<'TZ'> environment variable is changed in C<%ENV>, you can use :
  
      use POSIX;
      cast $ENV{TZ}, wizard set => sub { POSIX::tzset(); () };
  
  If you want to handle the possible deletion of the C<'TZ'> entry, you must also specify I<store> magic.
  
  =head2 C<getdata>
  
      getdata [$@%&*]var, $wiz
  
  This accessor fetches the private data associated with the magic C<$wiz> in the variable.
  It croaks when C<$wiz> does not represent a valid magic object, and returns an empty list if no such magic is attached to the variable or when the wizard has no data constructor.
  
      # Get the data attached to $wiz in $x, or undef if $wiz
      # did not attach any.
      my $data = getdata $x, $wiz;
  
  =head2 C<dispell>
  
      dispell [$@%&*]variable, $wiz
  
  The exact opposite of L</cast> : it dissociates C<$wiz> magic from the variable.
  This function returns true on success, C<0> when no magic represented by C<$wiz> could be found in the variable, and croaks if the supplied wizard is invalid.
  
      # Dispell now.
      die 'no such magic in $x' unless dispell $x, $wiz;
  
  =head1 CONSTANTS
  
  =head2 C<MGf_COPY>
  
  Evaluates to true if and only if the I<copy> magic is available.
  This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
  
  =head2 C<MGf_DUP>
  
  Evaluates to true if and only if the I<dup> magic is available.
  This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
  
  =head2 C<MGf_LOCAL>
  
  Evaluates to true if and only if the I<local> magic is available.
  This is the case for perl 5.9.3 and greater.
  
  =head2 C<VMG_UVAR>
  
  When this constant is true, you can use the I<fetch>, I<store>, I<exists> and I<delete> magics on hashes.
  Initial L</VMG_UVAR> capability was introduced in perl 5.9.5, with a fully functional implementation shipped with perl 5.10.0.
  
  =head2 C<VMG_COMPAT_SCALAR_LENGTH_NOLEN>
  
  True for perls that don't call I<len> magic when taking the C<length> of a magical scalar.
  
  =head2 C<VMG_COMPAT_SCALAR_NOLEN>
  
  True for perls that don't call I<len> magic on scalars.
  Implies L</VMG_COMPAT_SCALAR_LENGTH_NOLEN>.
  
  =head2 C<VMG_COMPAT_ARRAY_PUSH_NOLEN>
  
  True for perls that don't call I<len> magic when you push an element in a magical array.
  Starting from perl 5.11.0, this only refers to pushes in non-void context and hence is false.
  
  =head2 C<VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID>
  
  True for perls that don't call I<len> magic when you push in void context an element in a magical array.
  
  =head2 C<VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID>
  
  True for perls that don't call I<len> magic when you unshift in void context an element in a magical array.
  
  =head2 C<VMG_COMPAT_ARRAY_UNDEF_CLEAR>
  
  True for perls that call I<clear> magic when undefining magical arrays.
  
  =head2 C<VMG_COMPAT_HASH_DELETE_NOUVAR_VOID>
  
  True for perls that don't call I<delete> magic when you delete an element from a hash in void context.
  
  =head2 C<VMG_COMPAT_CODE_COPY_CLONE>
  
  True for perls that call I<copy> magic when a magical closure prototype is cloned.
  
  =head2 C<VMG_COMPAT_GLOB_GET>
  
  True for perls that call I<get> magic for operations on globs.
  
  =head2 C<VMG_PERL_PATCHLEVEL>
  
  The perl patchlevel this module was built with, or C<0> for non-debugging perls.
  
  =head2 C<VMG_THREADSAFE>
  
  True if and only if this module could have been built with thread-safety features enabled.
  
  =head2 C<VMG_FORKSAFE>
  
  True if and only if this module could have been built with fork-safety features enabled.
  This is always true except on Windows where it is false for perl 5.10.0 and below.
  
  =head2 C<VMG_OP_INFO_NAME>
  
  Value to pass with C<op_info> to get the current op name in the magic callbacks.
  
  =head2 C<VMG_OP_INFO_OBJECT>
  
  Value to pass with C<op_info> to get a C<B::OP> object representing the current op in the magic callbacks.
  
  =head1 COOKBOOK
  
  =head2 Associate an object to any perl variable
  
  This technique can be useful for passing user data through limited APIs.
  It is similar to using inside-out objects, but without the drawback of having to implement a complex destructor.
  
      {
       package Magical::UserData;
  
       use Variable::Magic qw<wizard cast getdata>;
  
       my $wiz = wizard data => sub { \$_[1] };
  
       sub ud (\[$@%*&]) : lvalue {
        my ($var) = @_;
        my $data = &getdata($var, $wiz);
        unless (defined $data) {
         $data = \(my $slot);
         &cast($var, $wiz, $slot)
                   or die "Couldn't cast UserData magic onto the variable";
        }
        $$data;
       }
      }
  
      {
       BEGIN { *ud = \&Magical::UserData::ud }
  
       my $cb;
       $cb = sub { print 'Hello, ', ud(&$cb), "!\n" };
  
       ud(&$cb) = 'world';
       $cb->(); # Hello, world!
      }
  
  =head2 Recursively cast magic on datastructures
  
  C<cast> can be called from any magical callback, and in particular from C<data>.
  This allows you to recursively cast magic on datastructures :
  
      my $wiz;
      $wiz = wizard data => sub {
       my ($var, $depth) = @_;
       $depth ||= 0;
       my $r = ref $var;
       if ($r eq 'ARRAY') {
        &cast((ref() ? $_ : \$_), $wiz, $depth + 1) for @$var;
       } elsif ($r eq 'HASH') {
        &cast((ref() ? $_ : \$_), $wiz, $depth + 1) for values %$var;
       }
       return $depth;
      },
      free => sub {
       my ($var, $depth) = @_;
       my $r = ref $var;
       print "free $r at depth $depth\n";
       ();
      };
  
      {
       my %h = (
        a => [ 1, 2 ],
        b => { c => 3 }
       );
       cast %h, $wiz;
      }
  
  When C<%h> goes out of scope, this prints something among the lines of :
  
      free HASH at depth 0
      free HASH at depth 1
      free SCALAR at depth 2
      free ARRAY at depth 1
      free SCALAR at depth 3
      free SCALAR at depth 3
  
  Of course, this example does nothing with the values that are added after the C<cast>.
  
  =head2 Delayed magic actions
  
  Starting with Variable::Magic 0.58, the return value of the magic callbacks can be used to delay the action until after the original action takes place :
  
      my $delayed;
      my $delayed_aux = wizard(
       data => sub { $_[1] },
       free => sub {
        my ($target) = $_[1];
        my $target_data = &getdata($target, $delayed);
        local $target_data->{guard} = 1;
        if (ref $target eq 'SCALAR') {
         my $orig = $$target;
         $$target = $target_data->{mangler}->($orig);
        }
        return;
       },
      );
      $delayed = wizard(
       data => sub {
        return +{ guard => 0, mangler => $_[1] };
       },
       set  => sub {
        return if $_[1]->{guard};
        my $token;
        cast $token, $delayed_aux, $_[0];
        return \$token;
       },
      );
      my $x = 1;
      cast $x, $delayed => sub { $_[0] * 2 };
      $x = 2;
      # $x is now 4
      # But note that the delayed action only takes place at the end of the
      # current statement :
      my @y = ($x = 5, $x);
      # $x is now 10, but @y is (5, 5)
  
  =head1 PERL MAGIC HISTORY
  
  The places where magic is invoked have changed a bit through perl history.
  Here is a little list of the most recent ones.
  
  =over 4
  
  =item *
  
  B<5.6.x>
  
  I<p14416> : I<copy> and I<dup> magic.
  
  =item *
  
  B<5.8.9>
  
  I<p28160> : Integration of I<p25854> (see below).
  
  I<p32542> : Integration of I<p31473> (see below).
  
  =item *
  
  B<5.9.3>
  
  I<p25854> : I<len> magic is no longer called when pushing an element into a magic array.
  
  I<p26569> : I<local> magic.
  
  =item *
  
  B<5.9.5>
  
  I<p31064> : Meaningful I<uvar> magic.
  
  I<p31473> : I<clear> magic was not invoked when undefining an array.
  The bug is fixed as of this version.
  
  =item *
  
  B<5.10.0>
  
  Since C<PERL_MAGIC_uvar> is uppercased, C<hv_magic_check()> triggers I<copy> magic on hash stores for (non-tied) hashes that also have I<uvar> magic.
  
  =item *
  
  B<5.11.x>
  
  I<p32969> : I<len> magic is no longer invoked when calling C<length> with a magical scalar.
  
  I<p34908> : I<len> magic is no longer called when pushing / unshifting an element into a magical array in void context.
  The C<push> part was already covered by I<p25854>.
  
  I<g9cdcb38b> : I<len> magic is called again when pushing into a magical array in non-void context.
  
  =back
  
  =head1 EXPORT
  
  The functions L</wizard>, L</cast>, L</getdata> and L</dispell> are only exported on request.
  All of them are exported by the tags C<':funcs'> and C<':all'>.
  
  All the constants are also only exported on request, either individually or by the tags C<':consts'> and C<':all'>.
  
  =cut
  
  use base qw<Exporter>;
  
  our @EXPORT         = ();
  our %EXPORT_TAGS    = (
   'funcs' =>  [ qw<wizard cast getdata dispell> ],
   'consts' => [ qw<
     MGf_COPY MGf_DUP MGf_LOCAL VMG_UVAR
     VMG_COMPAT_SCALAR_LENGTH_NOLEN
     VMG_COMPAT_SCALAR_NOLEN
     VMG_COMPAT_ARRAY_PUSH_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID
     VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID
     VMG_COMPAT_ARRAY_UNDEF_CLEAR
     VMG_COMPAT_HASH_DELETE_NOUVAR_VOID
     VMG_COMPAT_CODE_COPY_CLONE
     VMG_COMPAT_GLOB_GET
     VMG_PERL_PATCHLEVEL
     VMG_THREADSAFE VMG_FORKSAFE
     VMG_OP_INFO_NAME VMG_OP_INFO_OBJECT
   > ],
  );
  our @EXPORT_OK      = map { @$_ } values %EXPORT_TAGS;
  $EXPORT_TAGS{'all'} = [ @EXPORT_OK ];
  
  =head1 CAVEATS
  
  In order to hook hash operations with magic, you need at least perl 5.10.0 (see L</VMG_UVAR>).
  
  If you want to store a magic object in the private data slot, you will not be able to recover the magic with L</getdata>, since magic is not copied by assignment.
  You can work around this gotcha by storing a reference to the magic object instead.
  
  If you define a wizard with I<free> magic and cast it on itself, it results in a memory cycle, so this destructor will not be called when the wizard is freed.
  
  =head1 DEPENDENCIES
  
  L<perl> 5.8.
  
  A C compiler.
  This module may happen to build with a C++ compiler as well, but don't rely on it, as no guarantee is made in this regard.
  
  L<Carp> (core since perl 5), L<XSLoader> (since 5.6.0).
  
  =head1 SEE ALSO
  
  L<perlguts> and L<perlapi> for internal information about magic.
  
  L<perltie> and L<overload> for other ways of enhancing objects.
  
  =head1 AUTHOR
  
  Vincent Pit, C<< <perl at profvince.com> >>, L<http://www.profvince.com>.
  
  You can contact me by mail or on C<irc.perl.org> (vincent).
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-variable-magic at rt.cpan.org>, or through the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable-Magic>.
  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Variable::Magic
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017 Vincent Pit, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1; # End of Variable::Magic
PERL5_VARIABLE_MAGIC

$fatpacked{"perl5/XString.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL5_XSTRING';
  package XString;
  
  use strict;
  use warnings;
  
  # ABSTRACT: Isolated String helpers from B
  
  BEGIN {
  
      our $VERSION = '0.005'; # VERSION: generated by DZP::OurPkgVersion
      require XSLoader;
      XSLoader::load(__PACKAGE__);
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  XString - Isolated String helpers from B
  
  =head1 VERSION
  
  version 0.005
  
  =head1 SYNOPSIS
  
   #!perl
   
   use strict;
   use warnings;
   
   use Test::More;
   
   use XString;
   use B;
   
   is XString::cstring( q[a'string"with quotes] ), B::cstring( q[a'string"with quotes] ), q["a'string\"with quotes"];
   is XString::perlstring( q[a'string"with quotes] ), B::perlstring( q[a'string"with quotes] ), q["a'string\"with quotes"];
   
   done_testing;
  
  =head1 DESCRIPTION
  
  XString provides the L<B> string helpers in one isolated package.
  Right now only L<cstring> and L<perlstring> are available.
  
  =for markdown [![](https://github.com/atoomic/XString/workflows/linux/badge.svg)](https://github.com/atoomic/XString/actions) [![](https://github.com/atoomic/XString/workflows/macos/badge.svg)](https://github.com/atoomic/XString/actions) [![](https://github.com/atoomic/XString/workflows/windows/badge.svg)](https://github.com/atoomic/XString/actions)
  
  =head1 FUNCTIONS
  
  =head2 cstring(STR)
  
  Similar to B::cstring;
  Returns a double-quote-surrounded escaped version of STR which can
  be used as a string in C source code.
  
  =head2 perlstring(STR)
  
  Similar to B::perlstring;
  Returns a double-quote-surrounded escaped version of STR which can
  be used as a string in Perl source code.
  
  =head1 AUTHOR
  
  Nicolas R <atoomic@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2018 by cPanel, Inc.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PERL5_XSTRING

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# This program is part of MariaDB client tools
# See "COPYRIGHT, LICENSE, AND WARRANTY" at the end of this file for legal
# notices and disclaimers.

# This tool is "fat-packed": most of its dependent modules are embedded
# in this file.  Setting %INC to this file for each module makes Perl aware
# of this so it will not try to load the module from @INC.  See the tool's
# documentation for a full list of dependencies.

use strict;
use warnings FATAL => 'all';

our $use_hours = 0;
our $no_part_func = 0;

# ###########################################################################
# ProcessLog package 876f85f39dfeb6100fbb852f82cbf61c1e4d739a
# ###########################################################################
package ProcessLog;
use strict;
use warnings FATAL => 'all';

my $mail_available = 1;
eval 'use Mail::Send';
if($@) {
  $mail_available = 0;
}
use Sys::Hostname;
use Digest::MD5 qw(md5_hex);
use Time::HiRes qw(time);
use File::Spec;
use Fcntl qw(:seek);
use English qw(-no_match_vars);

use constant _PdbDEBUG => $ENV{Pdb_DEBUG} || 0;
use constant Level1 => 1;
use constant Level2 => 2;
use constant Level3 => 3;


sub new {
  my $class = shift;
  my ($script_name, $logpath, $email_to) = @_;
  my $self = {};

  $self->{run_id} = md5_hex(time . rand() . $script_name);

  $self->{script_name} = $script_name;
  $self->{log_path} = $logpath;
  $self->{email_to} = $email_to;
  $self->{stack_depth} = 10; # Show traces 10 levels deep.
  $self->{logsub} = 0;
  $self->{quiet} = 0;

  bless $self,$class;
  $self->logpath($logpath);
  return $self;
}

sub DESTROY {
  my ($self) = @_;
  if(ref($$self{'LOG'}) and ref($$self{'LOG'}) eq 'GLOB') {
    $$self{'LOG'}->flush();
  }
}


sub null {
  my $class = shift;
  $class->new('', '/dev/null', undef);
}


sub name {
  my $self = shift;
  $self->{script_name};
}


sub runid {
  my $self = shift;
  $self->{run_id};
}


sub start {
  my $self = shift;
  $self->m("BEGIN $self->{run_id}");
}


sub end {
  my $self = shift;
  $self->m("END $self->{run_id}");
}


sub stack_depth {
  my ($self, $opts) = @_;
  my $old = $self->{stack_depth};
  $self->{stack_depth} = $opts if( defined $opts );
  $old;
}


sub quiet {
  my ($self, $new) = @_;
  my $old = $self->{quiet};
  $self->{quiet} = $new if( defined $new );
  $old;
}


sub logpath {
  my ($self, $logpath) = @_;
  my $script_name = $$self{script_name};
  return $self->{log_path} if(not $logpath);
  $self->{log_path} = $logpath;
  if($logpath =~ /^syslog:(\w+)/) {
    require Sys::Syslog;
    Sys::Syslog::openlog($script_name, "", $1);
    $self->{logsub} = sub {
      my $self = shift;
      $_[3] = '';
      my $lvl = 'LOG_DEBUG';
      $lvl = 'LOG_INFO' if($_[0] eq "msg");
      $lvl = 'LOG_NOTICE' if($_[0] eq "ifo");
      $lvl = 'LOG_ERR'  if($_[0] eq "err");
      Sys::Syslog::syslog($lvl, _p(@_));
      print _p(@_) unless $self->{quiet};
    };
  }
  elsif($logpath eq 'pdb-test-harness' or $logpath eq 'stderr') {
    $self->{logsub} = sub {
      my $self = shift;
      my @args = @_;
      $args[0] =~ s/^/# /;
      print STDERR _p(@args);
    }
  }
  else {
    open $self->{LOG}, ">>$self->{log_path}" or die("Unable to open logfile: '$self->{log_path}'.\n");
    binmode($self->{LOG});
    $self->{logsub} = sub {
      my $self = shift;
      my $fh  = $self->{LOG};
      print $fh _p(@_);
      print _p(@_) unless $self->{quiet};
    };
  }
  return $self;
}


sub email_to {
  my ($self, @emails) = @_;
  my $old = $$self{email_to};
  if(@emails) {
    $$self{email_to} = [@emails];
  }
  return $old;
}


sub m {
  my ($self,$m) = shift;
  my $fh = $self->{LOG};
  my $t = sprintf("%.3f", time());
  $self->{logsub}->($self, 'msg', undef, undef, $t, @_);
}


sub ms {
  my $self = shift;
  $self->m(@_);
  $self->m($self->stack());
}


sub p {
  my ($self) = shift;
  my $fh = \*STDIN;
  my $regex = qr/.*/;
  my $default = undef;
  my @prompt = ();
  if(ref($_[0]) eq 'GLOB') {
    $fh = shift;
  }
  if(ref($_[-1]) eq 'Regexp') {
    $regex = pop;
  }
  elsif(ref($_[-2]) eq 'Regexp') {
    $default = pop;
    $regex = pop;
  }
  @prompt = @_;
  $self->m(@prompt);
  chomp($_ = <$fh>);
  if($default and $_ eq '') {
    $self->m('Using default:', $default);
    return $default;
  }
  while($_ !~ $regex) {
    $self->d("Input doesn't match:", $regex);
    $self->m(@prompt);
    chomp($_ = <$fh>);
  }

  $self->m('Using input:', $_);
  return $_;
}


sub e {
  my ($self,$m) = shift;
  my ($package, undef, $line) = caller 0;
  my $fh = $self->{LOG};
  my $t = sprintf("%.3f", time());
  $self->{logsub}->($self, 'err', $package, $line, $t, @_);
}


sub ed {
  my ($self) = shift;
  $self->e(@_);
  die(shift(@_) . "\n");
}


sub es {
  my $self = shift;
  $self->e(@_);
  $self->e($self->stack());
}


sub i {
  my $self = shift;
  my $fh = $self->{LOG};
  my $t = sprintf("%.3f", time());
  $self->{logsub}->($self, 'ifo', undef, undef, $t, @_);
}


sub is {
  my $self = shift;
  $self->i(@_);
  $self->i($self->stack());
}


sub d {
  my $self = shift;
  my ($package, undef, $line) = caller 0;
  my $fh = $self->{LOG};
  if(_PdbDEBUG) {
    my $t = sprintf("%.3f", time());
    $self->{logsub}->($self, 'dbg', $package, $line, $t, @_);
  }
}


sub ds {
  my $self = shift;
  $self->d(@_);
  $self->d($self->stack());
}


sub x {
  my ($self, $subref, @args) = @_;
  my $r = undef;
  my $saved_fhs = undef;
  my $proc_fh = undef;
  eval {
    $saved_fhs = $self->_save_stdfhs();
    open($proc_fh, '+>', undef) or die("Unable to open anonymous tempfile");
    open(STDOUT, '>&', $proc_fh) or die("Unable to dup anon fh to STDOUT");
    open(STDERR, '>&', \*STDOUT) or die("Unable to dup STDOUT to STDERR");
    $r = $subref->(@args);
  };
  $self->_restore_stdfhs($saved_fhs);
  seek($proc_fh, 0, SEEK_SET);
  return {rcode => $r, error => $EVAL_ERROR . $self->stack, fh => $proc_fh};
}


sub stack {
  my ($self, $level, $top) = @_;
  $level = $self->{stack_depth} ||= 10 unless($level);
  $top   = (defined $top ? $top : 2);
  my $out = "";
  my $i=0;
  my ($package, $file, $line, $sub) = caller($i+$top); # +2 hides ProcessLog from the stack trace.
  $i++;
  if($package) {
    $out .= "Stack trace:\n";
  }
  else {
    $out .= "No stack data available.\n";
  }
  while($package and $i < $level) {
    $out .= " "x$i . "$package  $file:$line  $sub\n";
    ($package, $file, $line, $sub) = caller($i+$top);
    $i++;
  }
  chomp($out);
  $out;
}

sub _p {
  my $mode = shift;
  my $package = shift;
  my $line = shift;
  my $time = shift;
  my $prefix = "$mode";
  $prefix .= " ${package}:${line}" if(defined $package and defined $line);
  $prefix .= $time ? " $time: " : ": ";
  @_ = map { (my $temp = $_) =~ s/\n/\n$prefix/g; $temp; }
       map { defined $_ ? $_ : 'undef' } @_;
  $prefix. join(' ',@_). "\n";
}

sub _flush {
  my ($self) = @_;
  unless($self->{log_path} =~ /^syslog:/) {
    $self->{LOG}->flush;
  }
  1;
}

sub _save_stdfhs {
  my ($self) = @_;
  open my $stdout_save, ">&", \*STDOUT or die("Unable to dup stdout");
  open my $stderr_save, ">&", \*STDERR or die("Unable to dup stderr");
  return { o => $stdout_save, e => $stderr_save };
}

sub _restore_stdfhs {
  my ($self, $fhs) = @_;
  my $o = $fhs->{o};
  my $e = $fhs->{e};
  open STDOUT, ">&", $o;
  open STDERR, ">&", $e;
  return 1;
}


sub email_and_die {
  my ($self, $extra) = @_;
  $self->e("Mail sending not available. Install Mail::Send, or perl-MailTools on CentOS") and die("Cannot mail out") unless($mail_available);
  $self->failure_email($extra);
  die($extra);
}


sub failure_email {
  my ($self,$extra) = @_;
  $self->send_email("$self->{script_name} FAILED", $extra);
}

sub success_email {
  my ($self, $extra) = @_;

  $self->send_email("$self->{script_name} SUCCESS", $extra);
}

sub send_email {
  my ($self, $subj, $body, @extra_to) = @_;
  $body ||= "No additional message attached.";
  my @to;
  unless( $mail_available ) {
    $self->e("Mail sending not available. Install Mail::Send, or perl-MailTools on CentOS");
    return 0;
  }
  unless( defined $self->{email_to} || @extra_to ) {
    $self->e("Cannot send email with no addresses.");
    return 0;
  }
  @to = ( (ref($self->{email_to}) eq 'ARRAY' ? @{$self->{email_to}} : $self->{email_to}), @extra_to );

  my $msg = Mail::Send->new(Subject => $subj);
  $msg->to(@to);
  my $fh = $msg->open;
  print($fh "Message from ", $self->{script_name}, " on ", hostname(), "\n");
  print($fh "RUN ID: ", $self->{run_id}, "\n");
  print($fh "Logging to: ", ($self->{log_path} =~ /^syslog/ ?
                               $self->{log_path}
                                 : File::Spec->rel2abs($self->{log_path})),
        "\n\n");
  print($fh $body);
  print($fh "\n");

  $fh->close;
}


{
  no strict 'refs';
  no warnings 'once';
  *::PL = \(ProcessLog->new($0, '/dev/null'));
}


1;
# ###########################################################################
# End ProcessLog package
# ###########################################################################

# ###########################################################################
# DSN package 13f9a3c9df3506bad80034eedeb6ba834aa1444d
# ###########################################################################
package DSN;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Storable;

sub _create {
  my ($class, $keys) = @_;
  my $self = {};
  $self = _merge($self, $keys);
  return bless $self, $class;
}

sub STORABLE_freeze {
  my ($self, $cloning) = @_;
  return if $cloning;
  my $f = {};
  _merge($f, $self);
  return (
    Storable::nfreeze($f)
  );
}

sub STORABLE_thaw {
  my ($self, $cloning, $serialized) = @_;
  return if $cloning;
  my $f = Storable::thaw($serialized);
  return _merge($self, $f);
}

sub STORABLE_attach {
  my ($class, $cloning, $serialized) = @_;
  return if $cloning;
  my $f = Storable::thaw($serialized);
  return $class->_create($f);
}

sub DESTROY {}

sub get {
  my ($self, $k) = @_;
  return $self->{$k}->{'value'};
}

sub has {
  my ($self, $k) = @_;
  return exists $self->{$k}->{'value'};
}

sub str {
  my ($self) = @_;
  my $str = "";
  for(sort keys %$self) {
    $str .= "$_=". $self->get($_) ."," if($self->has($_));
  }
  chop($str);
  return $str;
}

sub get_dbi_str {
  my ($self, $extra_opts) = @_;
  $extra_opts ||= {};
  my %set_implied = ();
  my %dsn_conv = (
    'h' => 'host',
    'P' => 'port',
    'F' => 'mysql_read_default_file',
    'G' => 'mysql_read_default_group',
    'S' => 'mysql_socket',
    'D' => 'database',
    'SSL_key' => 'mysql_ssl_client_key',
    'SSL_cert' => 'mysql_ssl_client_cert',
    'SSL_CA' => 'mysql_ssl_ca_file',
    'SSL_CA_path' => 'mysql_ssl_ca_path',
    'SSL_cipher' => 'mysql_ssl_cipher'
  );
  my %opt_implied = (
    'SSL_key' => 'mysql_ssl=1',
    'SSL_cert' => 'mysql_ssl=1',
    'SSL_CA' => 'mysql_ssl=1',
    'SSL_CA_path' => 'mysql_ssl=1',
    'SSL_cipher' => 'mysql_ssl=1'
  );

  my $dbh_str = 'DBI:mysql:';

  for(sort keys(%$self)) {
    if(exists($opt_implied{$_}) and $self->has($_) and !$set_implied{$opt_implied{$_}}) {
      $dbh_str .= $opt_implied{$_} . ';';
      $set_implied{$opt_implied{$_}} = 1;
    }
    $dbh_str .= $dsn_conv{$_} .'='. ($self->get($_) || '') .';'
    if(exists($dsn_conv{$_}) and $self->has($_));
  }
  if(%$extra_opts) {
    $dbh_str .= join(';',
      map { "$_=". $$extra_opts{$_} } sort keys(%$extra_opts));
  }
  return $dbh_str;
}

sub get_dbh {
  my ($self, $cached, $extra_opts, $extra_dbi_opts) = @_;
  my $dbh_str = $self->get_dbi_str($extra_dbi_opts);
  my $options = _merge({ 'AutoCommit' => 0, 'RaiseError' => 1,
        'PrintError' => 0, 'ShowErrorStatement' => 1 }, ($extra_opts || {}));
  my $dbh;

  if($cached) {
    $dbh = DBI->connect_cached($dbh_str, $self->get('u'), $self->get('p'),
      $options);
  }
  else {
    $dbh = DBI->connect($dbh_str, $self->get('u'), $self->get('p'),
      $options);
  }
  if($self->has('N')) {
    $dbh->do('SET NAMES '. $dbh->quote($self->get('N')));
  }
  if($self->has('vars')) {
    my $vars = join(', ', map {
        my ($k, $v) = split(/=/, $_, 2);
        $_ = $k . ' = ' . ($v =~ /^\d+$/ ? $v : $dbh->quote($v, 1));
        $_;
      } split(/;/, $self->get('vars')));
    $dbh->do('SET '. $vars);
  }
  return $dbh;
}

sub fill_in {
  my ($self, $from) = @_;
  $self = _merge($self, $from, 0);
  return $self;
}

sub _merge {
  my ($h1, $h2, $over, $p) = @_;
  foreach my $k (keys %$h2) {
    if(!ref($h2->{$k})) {
      if($over and exists $h1->{$k}) {
        $h1->{$k} = $h2->{$k};
      }
      elsif(!exists $h1->{$k}) {
        $h1->{$k} = $h2->{$k};
      }
    }
    elsif(ref($h2->{$k}) eq 'ARRAY') {
      $h1->{$k} = [];
      push @{$h1->{$k}}, $_ for(@{$h2->{$k}});
    }
    else {
      $h1->{$k} ||= {};
      _merge($h1->{$k}, $h2->{$k}, $over, $h1);
    }
  }
  $h1;
}

1;


package DSNParser;
use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Carp;

sub new {
  my ($class, $keys) = @_;
  croak('keys must be a hashref') unless(ref($keys));
  my $self = {};
  $self->{'keys'} = $keys;
  $self->{'allow_unknown'} = 0;
  return bless $self, $class;
}

sub add_key {
  my ($self, $key, $params) = @_;
  croak('params must be a hashref') unless(ref($params));
  if(exists $self->{'keys'}->{$key}) {
    croak("Key '$key' must not already exist");
  }
  $self->{'keys'}->{$key} = $params;
}

sub rem_key {
  my ($self, $key) = @_;
  unless(exists $self->{'keys'}->{$key}) {
    croak("Key '$key' must already exist");
  }
  delete $self->{'keys'}->{$key};
}

sub mand_key {
  my ($self, $key, $flag) = @_;
  unless(exists $self->{'keys'}->{$key}) {
    croak("Key '$key' must already exist");
  }
  $self->{'keys'}->{$key}->{'mandatory'} = $flag;
}

sub default {
  my ($class) = @_;
  my $default_keys = {
    'h' => {
      'desc' => 'Hostname',
      'default' => '',
      'mandatory' => 0
    },
    'u' => {
      'desc' => 'Username',
      'default' => '',
      'mandatory' => 0
    },
    'p' => {
      'desc' => 'Password',
      'default' => '',
      'mandatory' => 0
    },
    'P' => {
      'desc' => 'Port',
      'default' => 3306,
      'mandatory' => 0
    },
    'F' => {
      'desc' => 'Defaults File',
      'default' => '',
      'mandatory' => 0
    },
    'G' => {
      'desc' => 'Defaults File Group',
      'default' => 'client',
      'mandatory' => 0
    },
    'D' => {
      'desc' => 'Database name',
      'default' => '',
      'mandatory' => 0
    },
    't' => {
      'desc' => 'Table name',
      'default' => '',
      'mandatory' => 0
    },
    'S' => {
      'desc' => 'Socket path',
      'default' => '',
      'mandatory' => 0
    },
    'N' => {
      'desc' => 'Client character set',
      'default' => '',
      'mandatory' => 0
    },
    'vars' => {
      'desc' => 'Extra client variables',
      'default' => '',
      'mandatory' => 0
    },
    'sU' => {
      'desc' => 'SSH User',
      'default' => '',
      'mandatory' => 0
    },
    'sK' => {
      'desc' => 'SSH Key',
      'default' => '',
      'mandatory' => 0
    },
    'SSL_key' => {
      'desc' => 'SSL client key',
      'default' => '',
      'mandatory' => 0
    },
    'SSL_cert' => {
      'desc' => 'SSL client certificate',
      'default' => '',
      'mandatory' => 0
    },
    'SSL_CA' => {
      'desc' => 'SSL client CA file',
      'default' => '',
      'mandatory' => 0
    },
    'SSL_CA_path' => {
      'desc' => 'SSL client CA path',
      'default' => '',
      'mandatory' => 0
    },
    'SSL_cipher' => {
      'desc' => 'SSL cipher',
      'default' => '',
      'mandatory' => 0
    }
  };
  return $class->new($default_keys);
}

sub parse {
  my ($self, $str) = @_;
  use Data::Dumper;
  $Data::Dumper::Indent = 0;
  my $dsn = DSN->_create($self->{'keys'});
  foreach my $kv ( split(/,/, $str) ) {
    my ($key, $val) = split(/=/, $kv, 2);
    croak('Unknown key: '. $key .' in dsn')
    unless($self->{'allow_unknown'} or exists($self->{'keys'}->{$key}) );
    $dsn->{$key}->{'value'} = $val;
  }
  foreach my $k ( keys %$dsn ) {
    if($dsn->{$k}->{'mandatory'} and ! exists($dsn->{$k}->{'value'})) {
      croak('Missing key: '. $k .' ['. ($self->{'keys'}->{$k}->{'desc'}||'no description') .'] in dsn');
    }
  }
  return $dsn;
}


1;
# ###########################################################################
# End DSN package
# ###########################################################################

# ###########################################################################
# TablePartitions package bf38632f606e6c5d8d6c94691979a33e334690e2
# ###########################################################################
package TablePartitions;
use strict;
use warnings FATAL => 'all';

use English qw(-no_match_vars);
use Data::Dumper;

use DBI;

sub new {
  my ( $class, $pl, $dsn ) = @_;
  my $self = ();
  $self->{dbh} = $dsn->get_dbh(1);
  $self->{pl} = $pl;
  $self->{schema} = $dsn->get('D');
  $self->{name} = $dsn->get('t');
  bless $self, $class;

  $self->_get_partitions();

  if($self->{partition_method} ne 'RANGE') {
    return undef;
  }
  else {
    return $self;
  }
}

sub _get_version {
  my ($self) = @_;
  my $dbh = $self->{dbh};

  my ($version) = $dbh->selectrow_array('SELECT VERSION()');
  my ($major, $minor, $micro, $dist) = $version =~ /^(\d+)\.(\d+)\.(\d+)-(.*)/;
  unless($major) {
    ($major, $minor, $micro) = $version =~ /^(\d+)\.(\d+)\.(\d+)/;
    $dist = '';
  }
  ["$major.$minor", $major, $minor, $micro, $dist];
}

sub _get_partitions {
  my ($self) = @_;
  my $dbh = $self->{dbh};
  my ($release, undef, undef, undef, undef) = $self->_get_version();
  die("Server release not at least 5.1 ($release)") if ($release < 5.1);

  if(1) {
    $self->_get_partitions_by_IS();
  }
}

sub _get_partitions_by_IS {
  my ($self) = @_;
  my $dbh = $self->{dbh};

  my $qtd_schema = $dbh->quote($self->{schema});
  my $qtd_table  = $dbh->quote($self->{name});

  my $sql = "SELECT * FROM `information_schema`.`PARTITIONS` WHERE TABLE_SCHEMA=$qtd_schema AND TABLE_NAME=$qtd_table";

  $self->{pl}->d('SQL:', $sql);

  my $rows = $dbh->selectall_arrayref($sql, { Slice => {} });

  $self->{pl}->es("Table does not have any partitions, or does not exist.")
    and die("Table does not have any partitions, or does not exist")
  unless(scalar @$rows >= 1);

  $self->{partitions} = [];
  $self->{partition_method} = $rows->[0]->{PARTITION_METHOD};
  $self->{partition_expression} = $rows->[0]->{PARTITION_EXPRESSION};
  
  foreach my $r (@$rows) {
    my $p = {
      name => $r->{PARTITION_NAME},
      sub_name => $r->{SUBPARTITION_NAME},
      position => $r->{PARTITION_ORDINAL_POSITION},
      description => $r->{PARTITION_DESCRIPTION},
      sub_position => $r->{SUBPARTITION_ORDINAL_POSITION}
    };
    push @{$self->{partitions}}, $p;
  }
}

sub partitions {
  my ($self) = @_;
  $self->{pl}->d(Dumper($self->{partitions}));
  $self->{partitions}
}

sub first_partition {
  my ($self) = @_;
  $self->{partitions}->[0];
}

sub last_partition {
  my ($self) = @_;
  $self->{partitions}->[-1];
}

sub method {
  my ($self) = @_;
  $self->{partition_method};
}

sub expression {
  my ($self) = @_;
  $self->{partition_expression};
}

sub expression_column {
  my ($self) = @_;
  my ($col, $fn) = $self->expr_datelike;
  return $col if(defined($col));
  $self->{partition_expression} =~ /^\s*(A-Za-z\-_\$)\(([A-Za-z0-9\-_\$]+)\)/i;
  return $2 if ($1 and $2);
  return $self->{partition_expression};
}

sub expr_datelike {
  my ($self) = @_;
  my %datefuncs = ( 'to_days' => 'from_days', 'month' => 1, 'year' => 'rick_year', 'unix_timestamp' => 'from_unixtime', 'to_seconds' => 'rick_seconds' );
  $self->{partition_expression} =~ /^\s*([A-Za-z\-_\$]+)\(([A-Za-z0-9\-_\$`]+)\)/i;
  if(defined $1 and $datefuncs{lc($1)}) {
    	return ($2, $1, $datefuncs{lc($1)});
  }
  else {
    if ($no_part_func) {
    	return ($2, '', '');
    }
    else {
        return undef;
    }
  }
}

sub match_partitions {
  my ($self, $reg) = @_;
  my %res;
  map { $res{$_->{name}} = {name => $_->{name}, position => $_->{position}, description => $_->{description} } if($_->{name} =~ $reg); } @{$self->{partitions}};
  values %res;
}

sub has_maxvalue_data {
  my ($self) = @_;
  my $dbh = $self->{dbh};
  my $explain_result = undef;
  my $descr = undef;
  my $col = $self->expression_column;
  if ( $self->{partitions}->[-1]->{description} eq 'MAXVALUE' ) {
    $descr = $self->{partitions}->[-2]->{description};
    if($self->expr_datelike) {
      my (undef, $fn, $cfn) = $self->expr_datelike;
      if($fn) {
        $descr = "$cfn($descr)";
      }
    }
  }
  else {
    return 0; # Can't have maxvalue data since there isn't a partition for that.
  }
  my $sql =
      qq|SELECT COUNT(*) AS cnt
           FROM `$self->{schema}`.`$self->{name}`
         WHERE $col > $descr
        | ;
  $self->{pl}->d('SQL:', $sql);
  eval {
    $explain_result = $dbh->selectrow_hashref($sql);
    $self->{pl}->d(Dumper($explain_result));
  };
  if($EVAL_ERROR) {
    $self->{pl}->es($EVAL_ERROR);
    return undef;
  }
  return $explain_result->{cnt};
}

sub start_reorganization {
  my ($self, $p) = @_;
  die("Need partition name to re-organize") unless($p);
  my $part = undef;
  foreach my $par (@{$self->{partitions}}) {
    $part = $par if($par->{name} eq $p);
  }
  return undef unless($part);
  $self->{re_organizing} =  [];
  push @{$self->{re_organizing}},$part;
  return 1;
}

sub add_reorganized_part {
  my ($self, $name, $desc) = @_;
  return undef unless($self->{re_organizing});
  my ($col, $fn) = $self->expr_datelike;
  push @{$self->{re_organizing}}, {name => $name, description => $desc};
  return 1;
}

sub end_reorganization {
  my ($self, $pretend) = @_;
  return undef unless $self->{re_organizing};
  my $sql = "ALTER TABLE `$self->{schema}`.`$self->{name}` REORGANIZE PARTITION";
  my $orig_part = shift @{$self->{re_organizing}};
  my (undef, $fn) = $self->expr_datelike;
  $sql .= " $orig_part->{name} INTO (";
  while($_ = shift @{$self->{re_organizing}}) {
      $sql .= "\nPARTITION $_->{name} VALUES LESS THAN ";
    if(uc($_->{description}) eq 'MAXVALUE') {
      $sql .= 'MAXVALUE';
    }
    else {
      if($fn) {
        $sql .= "($fn(" . $self->{dbh}->quote($_->{description}) . '))';
      }
      else {
        $sql .= "(" . $_->{description} . ')';
      }
    }
    $sql .= ',';
  }
  chop($sql);
  $sql .= "\n)";
  $self->{pl}->d("SQL: $sql");
  eval {
    unless($pretend) {
      $self->{dbh}->do($sql);
      $self->_get_partitions();
    }
  };
  if($EVAL_ERROR) {
    $self->{pl}->e("Error reorganizing partition $orig_part->{name}: $@");
    return undef;
  }
  $self->{re_organizing} = 0;
  return 1;
}

sub add_range_partition {
  my ($self, $name, $description, $pretend) = @_;
  if($self->method ne 'RANGE') {
    $self->{pl}->m("Unable to add partition to non-RANGE partition scheme.");
    return undef;
  }
  for my $p (@{$self->{partitions}}) {
    if($p->{description} eq 'MAXVALUE') {
      $self->{pl}->m("Unable to add new partition when a catchall partition ($p->{name}) exists.");
      return undef;
    }
  }
  my (undef, $fn, $cfn) = $self->expr_datelike;
  my $qtd_desc = $self->{dbh}->quote($description);
  if (!$no_part_func) {
     $self->{pl}->d("SQL: ALTER TABLE `$self->{schema}`.`$self->{name}` ADD PARTITION (PARTITION $name VALUES LESS THAN ($fn(($qtd_desc)))");
  }
  else {
     $self->{pl}->d("SQL: ALTER TABLE `$self->{schema}`.`$self->{name}` ADD PARTITION (PARTITION $name VALUES LESS THAN ($description))");
  }
  eval {
    unless($pretend) {
      if (!$no_part_func) {
          $self->{dbh}->do("ALTER TABLE `$self->{schema}`.`$self->{name}` ADD PARTITION (PARTITION $name VALUES LESS THAN ($fn($qtd_desc)))");
          $self->_add_part($name, "to_days($qtd_desc)");
      }
      else {
          $self->{dbh}->do("ALTER TABLE `$self->{schema}`.`$self->{name}` ADD PARTITION (PARTITION $name VALUES LESS THAN ($description))");
          $self->_add_part($name, "($description)");
      }
    }
  };
  if($EVAL_ERROR) {
    $self->{pl}->e("Error adding partition: $@");
    return undef;
  }
  return 1;
}

sub drop_partition {
  my ($self, $name, $pretend) = @_;
  if($self->method ne 'RANGE') {
    $self->{pl}->m("Unable to drop partition from non-RANGE partition scheme.");
    return undef;
  }
  $self->{pl}->d("SQL: ALTER TABLE `$self->{schema}`.`$self->{name}` DROP PARTITION $name");
  eval {
    unless($pretend) {
      $self->{dbh}->do("ALTER TABLE `$self->{schema}`.`$self->{name}` DROP PARTITION $name");
      $self->_del_part($name);
    }
  };
  if($EVAL_ERROR) {
    $self->{pl}->e("Error dropping partition: $@");
    return undef;
  }

  return 1;
}

sub desc_from_datelike {
  my ($self, $name) = @_;
  my ($desc, $fn, $cfn) = $self->expr_datelike;

  if($self->method ne 'RANGE') {
    $self->{pl}->d("Only makes sense for RANGE partitioning.");
    return undef;
  }
  if (!$no_part_func and !$fn) {
      return undef;
  }

  for my $p (@{$self->{partitions}}) {
    if($p->{name} eq $name) {
      $desc = $p->{description};
      last;
    }
  }

  if ($no_part_func) {
  	my ($ds) = $self->{dbh}->selectrow_array("SELECT FROM_UNIXTIME($desc)");
  	return $ds;
  }
  if ($cfn eq "rick_year") {
  	my ($ds) = $self->{dbh}->selectrow_array("SELECT '$desc-01-01'");
  	return $ds;
  }
  if ($cfn eq "rick_seconds") {
  	my ($ds) = $self->{dbh}->selectrow_array("SELECT TIMESTAMPADD(SECOND, $desc - 86400, '0000-01-01 00:00:00')");
  	return $ds;
  }
  else {
  	$self->{pl}->d("SQL: SELECT $cfn($desc)");
  	my ($ds) = $self->{dbh}->selectrow_array("SELECT $cfn($desc)");
  	return $ds;
  }
}

sub _add_part {
  my ($self, $name, $desc) = @_;
  my ($d) = $self->{dbh}->selectrow_array("SELECT $desc");
  push @{$self->{partitions}}, {name => $name, description => $d, position => undef};
}

sub _del_part {
  my ($self, $name) = @_;
  my @replace = ();
  foreach my $p (@{$self->{partitions}}) {
    unless($p->{name} eq $name) {
      push @replace, $p;
    }
  }
  $self->{partitions} = \@replace;
}

1;

# ###########################################################################
# End TablePartitions package
# ###########################################################################

# ###########################################################################
# Timespec package 9c2ee59ea0b33f8cb8791bf3336cea9bc52d8643
# ###########################################################################
package Timespec;
use strict;
use warnings FATAL => 'all';
use DateTime;
use DateTime::Format::Strptime;
use Carp;

sub parse {
  my ($class, $str, $ref) = @_;
  if(not defined $ref) {
    $ref = DateTime->now(time_zone => 'local');
  }
  else {
    $ref = $ref->clone();
  }
  my $fmt_local = DateTime::Format::Strptime->new(pattern => '%F %T',
                                                  time_zone => 'local');
  my $fmt_tz = DateTime::Format::Strptime->new(pattern => '%F %T %O');
  $fmt_tz->parse_datetime($str);
  if($str =~ /^([-+]?)(\d+)([hdwmqy])(?:(?:\s|\.)(startof))?$/) {
    my ($spec, $amt) = ($3, $2);
    my %cv = ( 'h' => 'hours', 'd' => 'days', 'w' => 'weeks', 'm' => 'months', 'y' => 'years' );
    if($4) {
      if($cv{$spec}) {
        $_ = $cv{$spec};
        s/s$//;
        $ref->truncate(to => $_);
      }
      else { # quarters
        $ref->truncate(to => 'day');
        $ref->subtract(days => $ref->day_of_quarter()-1);
      }
    }

    if($spec eq 'q') {
      $spec = 'm';
      $amt *= 3;
    }

    if($1 eq '-') {
      $ref->subtract($cv{$spec} => $amt);
    }
    if($1 eq '+' or $1 eq '') {
      $ref->add($cv{$spec} => $amt);
    }
    return $ref;
  }
  elsif($str eq 'now') {
    return DateTime->now(time_zone => 'local');
  }
  elsif($str =~ /^(\d+)$/) {
    return DateTime->from_epoch(epoch => $1);
  }
  elsif($_ = $fmt_tz->parse_datetime($str)) {
    return $_;
  }
  elsif($_ = $fmt_local->parse_datetime($str)) {
    return $_;
  }
  else {
    croak("Unknown or invalid Timespec [$str] supplied.");
  }
}


1;
# ###########################################################################
# End Timespec package
# ###########################################################################

# ###########################################################################
# IniFile package d70faf2773ed7da1be74ef0675cf06f3f0c57122
# ###########################################################################
package IniFile;
use strict;
use warnings FATAL => 'all';
use File::Glob;


sub read_config {
  my $file = shift;
  my %cfg;
  my $inif;
  unless(open $inif, "<$file") {
    return undef;
  }
  my $cur_sec = '';
  while(<$inif>) {
    chomp;
    next if(/^\s*(?:;|#)/);
    next if(/^$/);
    if(/^\s*\[(\w+)\]/) { # Group statement
      $cfg{$1} = {};
      $cur_sec = $1;
    }
    elsif(/^!(include(?:dir)?)\s+([^\0]+)/) { # include directives
      my $path = $2;
      my @files;
      if($1 eq 'includedir') {
        @files = glob($path . "/*.cnf");
      }
      else {
        @files = ($path);
      }
      for(@files) { _merge(\%cfg, {read_config($_)}); }
    }
    else { # options and flags
      my ($k, $v) = split(/=/, $_, 2);
      $k =~ s/\s+$//;
      $k =~ s/^\s+//;
      if(defined($v)) {
        $v =~ s/^\s+//;
        $v =~ s/\s?#.*?[^"']$//;
        $v =~ s/^(?:"|')//;
        $v =~ s/(?:"|')$//;
      }
      else {
        if($k =~ /^(?:no-|skip-)(.*)/) {
          $k = $1;
          $v = 0;
        }
        else {
          $v = 1;
        }
      }
      chomp($k); chomp($v);

      if($k =~ /^(.*?)\s*\[\s*(\d+)?\s*\]/) {
        $k = $1;
        push @{$cfg{$cur_sec}{$k}}, $v;
        next;
      }
      $cfg{$cur_sec}{$k} = $v;
    }
  }
  return %cfg;
}

sub _merge {
  my ($h1, $h2, $p) = @_;
  foreach my $k (keys %$h2) {
    if(not $p and not exists $h1->{$k}) {
      $h1->{$k} = $h2->{$k};
    }
    elsif(not $p and exists $h1->{$k}) {
      _merge($h1->{$k}, $h2->{$k}, $h1);
    }
    elsif($p) {
      $h1->{$k} = $h2->{$k};
    }
  }
  $h1;
}

1;
# ###########################################################################
# End IniFile package
# ###########################################################################

package pdb_parted;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);



use DBI;
use Getopt::Long qw(:config no_ignore_case pass_through);
use Pod::Usage;
use DateTime;
use DateTime::Duration;
use DateTime::Format::Strptime;

use Data::Dumper;
{
  no warnings 'once';
  $Data::Dumper::Indent = 0;
  $Data::Dumper::Sortkeys = 1;
}

my $PL = $::PL ? $::PL : ProcessLog->new($0, '/dev/null');

my %o = (
  prefix  => 'p',
  logfile => '/dev/null',
);

sub main {
  @ARGV = @_;
  my (
    $r,
    $dsn,
    $remote_dsn,
    $parts,
    $timespec,
    $requested_dt,
    $email_log,
    @partitions
  );

  GetOptions(\%o,
    "help|h",
    "dryrun|n",
    "logfile|L=s",
    "quiet|q",
    "email-to|E=s",
    "email-activity",
    "use-hours",
    "partcol-integer",
    "prefix|P=s",
    "interval|i=s",
    "limit=i",
    "add",
    "drop",
    "archive",
    "archive-path=s",
    "archive-database=s",
    "i-am-sure",
  );

  $timespec = shift @ARGV;
  $dsn    = shift @ARGV;
  pod2usage("Missing TIMESPEC") if(!$timespec);
  pod2usage("Missing DSN") if(!$dsn);

  $email_log    = '';
  eval {
    $requested_dt = Timespec->parse($timespec);
    $dsn          = DSNParser->default()->parse($dsn);
  };
  if($@) {
    pod2usage($@);
  }

  unless($o{'drop'}) {
    # interval is not necessary for --drop.
    unless($o{'interval'} and $o{'interval'} =~ /^[hdwmqy]$/) {
      pod2usage("interval must be one of: h,d,w,m,q,y");
    }
  }

  unless($o{'prefix'} =~ /^[A-Za-z][A-Za-z0-9_-]*$/) {
    pod2usage("--prefix ($o{'prefix'}) must not include non alpha-numeric characters.");
  }

  unless($o{'add'} or $o{'drop'}) {
    pod2usage("ACTION required");
  }

  if($o{'add'} and $o{'drop'}) {
    pod2usage("Cannot perform more than one action at once");
  }

  if($o{'email-activity'} and !$o{'email-to'}) {
    pod2usage("--email-activity can only be used with --email-to.");
  }

  if($o{'archive-database'}) {
    eval {
      $remote_dsn = DSNParser->default()->parse($o{'archive-database'});
      $remote_dsn->mand_key('D');
      $remote_dsn->mand_key('t');
    };
    if($@) {
        pod2usage($@);
    }
  }

  $PL->start();
  $PL->email_to($o{'email-to'});
  $parts = TablePartitions->new($PL, $dsn);

  if($o{'use-hours'}) {
      $PL->m("Using hours instead of days!\n");
	$use_hours = 1;
  }
  if($o{'partcol-integer'}) {
      $PL->m("Assuming partitioning column is integer\n");
	$no_part_func = 1;
  }
  if($o{'add'}) {
    $email_log = "Adding partitions to ". $dsn->get('h') .
      "." . $dsn->get('D') . "." . $dsn->get('t') . ":\n";
    my $last_p = $parts->last_partition;
    my $last_d = to_date($parts->desc_from_datelike($last_p->{name}));
    if($last_d >= $requested_dt) {
      $PL->m("At least the requested partitions exist already.\n",
             'Requested out to:', $requested_dt->ymd(), "\n",
             'Partitions out to:', $last_d->ymd(), 'exist.');
      $r = 0; # success
      goto DONE;
    }
    eval {
      @partitions = add_partitions($dsn, $parts, $requested_dt, %o);
      $r = 0;
    };
    if($@) {
      $_ = "$@";
      $PL->e("Error adding partitions:", $_);
      $r = 1;
      goto DONE;
    }

    if($o{'email-activity'}) {
      for(@partitions) {
        $email_log .= "- $_->{name} [older than: $_->{date}]\n";
      }
      $PL->send_email("Partitions added on ". $dsn->get('h') .
                      "." . $dsn->get('D') . "." . $dsn->get('t'), $email_log);
    }
  }
  elsif($o{'drop'}) {
    $email_log = "Dropped partitions from ". $dsn->get('h') .
      "." . $dsn->get('D') . "." . $dsn->get('t') . ":\n";

    eval {
      @partitions = drop_partitions($dsn, $remote_dsn, $parts, $requested_dt, %o);
      $r = 0;
    };
    if($@) {
      $_ = "$@";
      $PL->e("Error dropping partitions:", $_);
      $r = 1;
      goto DONE;
    }

    if($o{'email-activity'}) {
      for(@partitions) {
        $email_log .= "- $_->{name} [older than: $_->{date}]\n";
      }
      $PL->send_email("Partitions dropped on ". $dsn->get('h') .
                      "." . $dsn->get('D') . "." . $dsn->get('t'), $email_log);
    }
  }

  DONE:
  $PL->failure_email() if($r);
  $PL->end();
  return $r;
}

sub interval {
  my $interval = shift;
  my %i = ( 'h' => 'hours', 'd' => 'days', 'w' => 'weeks',
            'm' => 'months', 'y' => 'years' );
  if($interval eq 'q') {
    return DateTime::Duration->new( months => 3 );
  }
  return DateTime::Duration->new( $i{$interval} => 1 );
}

sub add_partitions {
  my ($dsn, $parts, $end_date, %o) = @_;
  my $dbh = $dsn->get_dbh(1);
  die("missing mandatory argument prefix\n") unless($o{'prefix'});
  my $db_host = $dsn->get('h');
  my $db_schema = $dsn->get('D');
  my $db_table = $dsn->get('t');
  my $prefix = $o{'prefix'};
  my $i_am_sure = $o{'i-am-sure'};
  my $dryrun = $o{'dryrun'};
  my $interval = interval($o{'interval'});
  my @parts = ();

  my $i = 0;
  my $ret = 0;
  my $last_p = $parts->last_partition;
  my $next_pN = undef;
  my $curs_date = undef;

  my $reorganize = uc($last_p->{description}) eq 'MAXVALUE';

  if ($reorganize) {
    $last_p = $parts->partitions()->[-2];
    if ($parts->has_maxvalue_data and !$i_am_sure) {
      die("Data in MAXVALUE partition exists.\n");
    }
  }

  $last_p->{name} =~ /^$prefix(\d+)$/;
  $next_pN = $1;
  die("most recent partition didn't match /^$prefix(\\d+)\$/.\n")
    if (not defined($next_pN));
  $next_pN++;

  if (!$use_hours) {
  	$last_p->{date} = to_date($parts->desc_from_datelike($last_p->{name}));
  }
  else {
  	$last_p->{date} = to_hour($parts->desc_from_datelike($last_p->{name}));
  }
  $curs_date = $last_p->{date};

  $PL->d('Last partition:', $last_p->{date}->ymd);
  $PL->d('End date:', $end_date->ymd);

  ###########################################################################
  # Just loop until $curs_date (date cursor) is greater than
  # where we want to be. We advance the cursor by $range increments.
  ###########################################################################
  $i = 0;
  while ($curs_date < $end_date) {
    last if($o{'limit'} and $i >= $o{'limit'});
    push(@parts, {
      name => "$prefix". ($next_pN+$i),
      date => $curs_date->add_duration($interval)->clone(),
    });
    $i++;
  }

  $PL->i('Will add', scalar @parts, 'partition(s).', "\n",
         "Partitions: ",
         join(', ', map { "$_->{name}($_->{date})" } @parts), "\n");

  if ($reorganize) {
    $parts->start_reorganization($parts->last_partition()->{name});
    push(@parts, { name => "$prefix". ($next_pN+$i), date => 'MAXVALUE' });
  }

  ###########################################################################
  # Loop over the calculated dates and add partitions for each one
  ###########################################################################
  foreach my $part (@parts) {
    my $name = $part->{name};
    my $date = $part->{date};
    if ($reorganize) {
      if ($date eq 'MAXVALUE') {
        $parts->add_reorganized_part($part->{name}, $date);
      } else {
        $parts->add_reorganized_part($part->{name}, $date->ymd);
      }
    }
    else {
       if (!$use_hours) {
		if (!$no_part_func) {
     			$ret = $parts->add_range_partition($part->{name}, $date->ymd, $dryrun);
		}
		else {
     			$ret = $parts->add_range_partition($part->{name}, $date->epoch, $dryrun);
		}
       }
       else {
     		$ret = $parts->add_range_partition($part->{name}, $date, $dryrun);
       }
    }
  }

  if ($reorganize) {
    $ret = $parts->end_reorganization($dryrun);
    if(!$ret) {
      die("re-organizing\n");
    }
  }

  return @parts;
}

sub drop_partitions {
  my ($dsn, $remote_dsn, $parts, $requested_dt, %o) = @_;
  my @drops;
  foreach my $part (@{$parts->partitions()}) {
    if (!$use_hours) {
    	$part->{date} = to_date($parts->desc_from_datelike($part->{name}));
    }
    else {
    	$part->{date} = to_hour($parts->desc_from_datelike($part->{name}));
    }
    if($part->{date} < $requested_dt) {
      push @drops, $part;
    }
    last if($o{'limit'} and scalar @drops >= $o{'limit'});
  }

  $PL->i('Will drop', scalar @drops, 'partition(s).', "\n",
         "Partitions: ",
         join(', ', map { "$_->{name}($_->{date})" } @drops), "\n");

  foreach my $part (@drops) {
    if($o{'archive'}) {
      archive_partition($dsn, $remote_dsn, $parts, $part, %o);
    }
    if(!$parts->drop_partition($part->{name}, $o{'dryrun'})) {
      die("$part->{name} $part->{date}");
    }
  }
  return @drops;
}

sub archive_partition {
  my ($dsn, $remote_dsn, $parts, $part, %o) = @_;
  my $path = $o{'archive-path'} || "";
  if($path) {
    $path =~ s/[^\/]$/\//;
  }
  my $host = $dsn->get('h');
  my $user = $dsn->get('u');
  my $pw = $dsn->get('p');
  my $schema = $dsn->get('D');
  my $table = $dsn->get('t');

  my $dfile = $dsn->get('F');
  my $r;

  my ($remote_host, $remote_user, $remote_pw, $remote_schema, $remote_table);
  if($remote_dsn) {
    $remote_host = $remote_dsn->get('h');
    $remote_user = $remote_dsn->get('u');
    $remote_pw = $remote_dsn->get('p');
    $remote_schema = $remote_dsn->get('D');
    $remote_table = $remote_dsn->get('t');
  }

  my $create_file = "${path}$host.$schema.$table.". $part->{name} . ".CREATE.sql";
  my $create_clean_file = "${path}$host.$schema.$table.". $part->{name} . ".CREATE.CLEAN.sql";

  my ($desc, $fn, $cfn) = $parts->expr_datelike();
  if($cfn) {
    $desc = "$cfn(". $part->{description} . ")";
  }
  else {
    $desc = $part->{description};
  }
  my @dump_EXEC;

  # Archive to file
  my $output_file = "${path}$host.$schema.$table.". $part->{name} . ".sql";
  @dump_EXEC = ("mysqldump",
                ( $dfile ? ("--defaults-file=$dfile") : () ),
                "--no-create-info",
                "--result-file=". $output_file,
                ($host ? ("-h$host") : () ),
                ($user ? ("-u$user") : () ),
                ($pw ? ("-p$pw") : () ),
                "-w ". $parts->expression_column() . "<$desc",
                $schema,
                $table);
  $PL->i("Archiving:", $part->{name}, "to", $output_file);

  $PL->d("Executing:", @dump_EXEC);
  unless($o{'dryrun'}) {
    $r = $PL->x(sub { system(@_) }, @dump_EXEC);
  }
  else {
    $r = { rcode => 0, error => '', fh => undef };
  }
  if(($$r{rcode} >> 8) != 0) {
    $_ = $$r{fh};
    while (<$_>) { $PL->e($_); }
    $PL->e("got:", ($$r{rcode} >> 8), "from mysqldump.");
    die("archiving $host.$schema.$table.$part->{name}\n");
  }

  if($remote_dsn) {
    # Archive to another database

    # Invoke the commands on the remote database and archive our data.
    # This assumes that the remote database and table have already been created.
    $PL->i("Archiving:", $part->{name}, "to $remote_schema on $remote_host");
    my @archive_EXEC = ("mysql",
                        ( $dfile ? ("--defaults-file=$dfile") : () ),
                        ($remote_host ? ("-h$remote_host") : () ),
                        ($remote_user ? ("-u$remote_user") : () ),
                        ($remote_pw ? ("-p$remote_pw") : () ),
                        '--execute=source '.$output_file,
                        $remote_schema,
        );

    unless($o{'dryrun'}) {
      $r = $PL->x(sub { system(@_) }, @archive_EXEC);
    }
    else {
      $r = { rcode => 0, error => '', fh => undef };
    }
    if(($$r{rcode} >> 8) != 0) {
      $_ = $$r{fh};
      while (<$_>) { $PL->e($_); }
      $PL->e("got:", ($$r{rcode} >> 8), "from mysqldump.");
      die("archiving $host.$schema.$table.$part->{name}\n");
    }
  }
}

sub to_date {
  my ($dstr) = @_;
  #############################################################################
  # MySQL can return two different kinds of dates to us.
  # For DATE columns we just get the date. Obviously.
  # For virtually all other time related columns, we also get a time.
  # This method first tries parsing with just dates and then tries with time.
  #############################################################################
  my $fmt1 = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d', time_zone => 'local');
  my $fmt2 = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %T', time_zone => 'local');
  return ($fmt1->parse_datetime($dstr) || $fmt2->parse_datetime($dstr))->truncate( to => 'day' );
}

sub to_hour {
  my ($dstr) = @_;
  # RICK  return hours not days
  my $fmt2 = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %T', time_zone => 'local');
  return ($fmt2->parse_datetime($dstr));
}


# ############################################################################
# Run the program.
# ############################################################################
if(!caller) { exit(main(@ARGV)); }

1; # Because this is a module as well as a script.

# #############################################################################
# Documentation.
# #############################################################################

=pod

=head1 NAME

mariadb-parted - MySQL partition management script

=head1 EXAMPLES

  # Create weekly partitions for the next quarter to test.part_table
  mariadb-parted --add --interval w +1q h=localhost,D=test,t=part_table

  # Create daily partitions for the next 2 weeks
  # starting exactly at the beginning of every day
  mariadb-parted --add --interval d +2w.startof h=localhost,D=test,t=part_table

  # Email ops@example.com about partitions added
  mariadb-parted --add --email-activity --email-to ops@example.com \
             --interval d +4w h=localhost,D=test,t=part_table

  # Drop partitions older than 8 weeks
  mariadb-parted --drop -8w h=localhost,D=test,t=part_table

  # Drop partitions older than Dec 20th, 2010, but only 5 of them.
  mariadb-parted --drop --limit 5 '2010-12-20 00:00:00' \
             h=localhost,D=test,t=part_table

  # Drop and archive partitions older than 2 quarters ago.
  mariadb-parted --drop --archive --archive-path /backups -2q \
             h=locahost,D=test,t=part_table

  # Same as above, but archived to a separate database.
  mariadb-parted --drop --archive --archive-database h=remotehost,D=test_archives,t=part_table -2q \
             h=locahost,D=test,t=part_table

  # Logging to syslog
  mariadb-parted --logfile syslog:LOCAL0 --add --interval d 1y \
             h=localhost,D=test,t=part_table


=head1 SYNOPSIS

mariadb-parted [options] ACTION TIMESPEC DSN

This tool assists in the creation of partitions in regular intervals.
It creates partitions in regular intervals up to some maximum future date.

  --help,          -h   This help. See C<perldoc mariadb-parted> for full docs.
  --dryrun,        -n   Report on actions without taking them.
  --logfile,       -L   Direct output to given logfile. Default: none.

  --email-activity      Send a brief email report of actions taken.
                        The email is sent to --email-to.
  --use-hours 	        Use hours instead of days when checking partitions.
  --partcol-integer     Assume no partitioning time or date function in use
  --email-to,      -E   Where to send activity and failure emails.
                        Default: none.

  --prefix,        -P   Partition prefix. Defaults to 'p'.

  --archive             Archive partitions before dropping them.
  --archive-path        Directory to place mysqldumps.
                        Default: current directory.
  --archive-database    Database to archive partitions to.
                        Default: none

  --limit,         -m   Limit the number of actions to be performed.
                        Default: 0 (unlimited)

=head2 ACTION

  --add   Add partitions.
  --drop  Remove partitions.

=head2 TIMESPEC

A timespec is a "natural" string to specify how far in advance to create
partitions. A sampling of possible timespecs:

  1w (create partitions one week in advance)
  1m (one month)
  2q (two quarters)
  5h (five hours)

See the full documentation for a complete description of timespecs.

=head2 DSN

DSNs, such as those passed as option values, or arguments to a program
are of the format: C<({key}={value}(,{key}={value})*>. That is, a C<key=value> pair, followed
by a comma, followed by any number of additional C<key=value> pairs separated by
commas.

Examples:

  h=testdb1,u=pdb,p=frogs
  h=localhost,S=/tmp/mysql.sock,u=root,F=/root/my.cnf

Where 'h' is a hostname, 'S' is a socket path, 'u' is a user, 'F' is a path
to a defaults file, and 'p' is a password. These are non-exhaustive examples.

=head1 TIMESPEC

A timespec is one of:

  A modifier to current local time,
  A unix timestamp (assumed in UTC),
  The string 'now' to refer to current local time,
  An absolute time in 'YYYY-MM-DD HH:MM:SS' format,
  An absolute time in 'YYYY-MD-DD HH:MM:SS TIMEZONE' format.

For the purposes of this module, TIMEZONE refers to zone names
created and maintained by the zoneinfo database.
See L<http://en.wikipedia.org/wiki/Tz_database> for more information.
Commonly used zone names are: Etc/UTC, US/Pacific and US/Eastern.

Since the last four aren't very complicated, this section describes
what the modifiers are.

A modifer is, an optional plus or minus sign followed by a number,
and then one of:

  y = year, q = quarter , m = month, w = week, d = day, h = hour

Followed optionally by a space or a period and 'startof'.
Which is described in the next section.

Some examples (the time is assumed to be 00:00:00):

  -1y         (2010-11-01 -> 2009-11-01)
   5d         (2010-12-10 -> 2010-12-15)
  -1w         (2010-12-13 -> 2010-12-07)
  -1q startof (2010-05-01 -> 2010-01-01)
   1q.startof (2010-05-01 -> 2010-07-01)

=head2 startof

The 'startof' modifier for timespecs is a little confusing,
but, is the only sane way to achieve latching like behavior.
It adjusts the reference time so that it starts at the beginning
of the requested type of interval. So, if you specify C<-1h startof>,
and the current time is: C<2010-12-03 04:33:56>, first the calculation
throws away C<33:56> to get: C<2010-12-03 04:00:00>, and then subtracts
one hour to yield: C<2010-12-03 03:00:00>.

Diagram of the 'startof' operator for timespec C<-1q startof>,
given the date C<2010-05-01 00:00>.

          R P   C
          v v   v
   ---.---.---.---.---.--- Dec 2010
   ^   ^   ^   ^   ^   ^
   Jul Oct Jan Apr Jul Oct
  2009    2010

  . = quarter separator
  C = current quarter
  P = previous quarter
  R = Resultant time (2010-01-01 00:00:00)

=head1 OPTIONS

=over 8

=item --help, -h

This help.

=item --dryrun, -n

Report on actions that would be taken. Works best with the C<Pdb_DEBUG> environment variable set to true.

See also: L<ENVIRONMENT>

=item --logfile, -L

Path to a file for logging, or, C<< syslog:<facility> >>
Where C<< <facility> >> is a pre-defined logging facility for this machine.

See also: L<syslog(3)>, L<syslogd(8)>, L<syslog.conf(5)>

=item --email-to, -E

Where to send emails.

This tool can send emails on failure, and whenever it adds, drops, or archive partitions.
Ordinarily, it will only send emails on failure.

=item --email-activity

If this flag is present, then this will make the tool also email
whenver it adds, drops, or archives a partition.

=item --use-hours

If this flag is present, then partitions will be checked on the hour and not on the day.
Useful when you need to partition by hour.

=item --partcol-integer

If this flag is present, then the tool will assume there is no partitioning function
defined, e.g. if you are storing your date into an integer column

=item --prefix, -P

Prefix for partition names. Partitions are always named like: <prefix>N.
Where N is a number. Default is 'p', which was observed to be the most common prefix.

=item --interval, -i

type: string one of: d w m y

Specifies the size of the each partition for the --add action.
'd' is day, 'w' is week, 'm' is month, and 'y' is year.

=item --limit

Specifies a limit to the number of partitions to add, drop, or archive.
By default this is unlimited (0), so, for testing one usually wishes to set
this to 1.

=item --archive

type: boolean

mysqldump partitions to files B<in the current directory> named like <host>.<schema>.<table>.<partition_name>.sql

There is not currently a way to archive without dropping a partition.

=item --archive-path

What directory to place the SQL dumps of partition data in.

=item --archive-database

What database to place the archived partitions in.

=back

=head1 ACTIONS

=over 8

=item --add

Adds partitions till there are at least TIMESPEC L<--interval> sized future buckets.

The adding of partitions is not done blindly. This will only add new partitions
if there are fewer than TIMESPEC future partitions. For example:

  Given: --interval d, today is: 2011-01-15, TIMESPEC is: +1w,
         last partition (p5) is for 2011-01-16;

  Result:
    Parted will add 6 partitions to make the last partition 2011-01-22 (p11).

  Before:
   |---+|
  p0  p5

  After:
   |---+-----|
  p0  p5    p11

You can think of C<--add> as specifying a required minimum safety zone.

=item --drop

Drops partitions strictly older than TIMESPEC.
The partitions are not renumbered to start with p0 again.

  Given: today is: 2011-01-15, TIMESPEC is: -1w,
         first partition (p0) is for 2011-01-06


  Result: 2 partitions will be dropped.

  Before: |-----+--|
          0     6  9
  After : |---+--|
          2   6  9

=back

=head1 ENVIRONMENT

Due to legacy reasons, this tool respond to the environment variable C<Pdb_DEBUG> 
instead of PTDEBUG. This variable, when set to true, enables additional (very 
verbose) output from the tool.

=head1 SYSTEM REQUIREMENTS

You need Perl, DBI, DBD::mysql, and some core packages that ought to be
installed in any reasonably new version of Perl.

=head1 ABOUT THIS MARIADB TOOL

This tool is part of MariaDB client tools. This MariaDB Tool was forked from
PalominoDB's pdb-parted in 2019.

=head1 COPYRIGHT, LICENSE, AND WARRANTY

This program is copyright 2019-2021 MariaDB Corporation and/or its affiliates,
2009-2013 PalominoDB, Inc.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 VERSION

mariadb-parted 6.0.0a

=cut
